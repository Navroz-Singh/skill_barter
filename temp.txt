File: /data/helpFAQs.js

// data/helpFAQs.js

export const helpFAQs = [
    // Exchange Process (10 FAQs)
    {
        id: 1,
        question: "How do I start an exchange?",
        answer: "To start an exchange, browse skills on the platform, find a skill you're interested in, and click 'Request Exchange'. You'll then specify what you're offering in return (your skill or payment) and provide details about your offer.",
        category: "Exchange Process"
    },
    {
        id: 2,
        question: "What are the different exchange statuses?",
        answer: "Exchange statuses are: Pending (initial request), Negotiating (discussing terms), Pending Acceptance (one party accepted), Accepted (both parties agreed), In Progress (exchange happening), Completed (finished), Cancelled, or Expired.",
        category: "Exchange Process"
    },
    {
        id: 3,
        question: "How does the negotiation process work?",
        answer: "During negotiation, both parties can chat, discuss terms, set deliverables, and agree on timeline. Once both parties accept the terms, the exchange moves to 'Accepted' status and you can begin the actual skill exchange.",
        category: "Exchange Process"
    },
    {
        id: 4,
        question: "What happens after both parties accept an exchange?",
        answer: "Once both parties accept, the exchange status changes to 'In Progress'. You can then start the actual skill exchange, communicate directly, and work on the agreed deliverables.",
        category: "Exchange Process"
    },
    {
        id: 17,
        question: "How do I cancel an exchange?",
        answer: "You can cancel an exchange during the 'Pending' or 'Negotiating' stages by going to your exchange details and clicking 'Cancel Exchange'. Once both parties have accepted, cancellation requires mutual agreement or contacting support.",
        category: "Exchange Process"
    },
    {
        id: 18,
        question: "Can I modify my offer after submitting?",
        answer: "Yes, during the negotiation phase you can modify your offer details, deliverables, timeline, and terms. Any changes will reset the acceptance status and require both parties to re-agree to the updated terms.",
        category: "Exchange Process"
    },
    {
        id: 19,
        question: "What delivery methods are available for exchanges?",
        answer: "You can choose from three delivery methods: In-person (face-to-face meetings), Online (video calls, digital delivery), or Both (flexible approach). Specify your preferred method when creating your skill listing.",
        category: "Exchange Process"
    },
    {
        id: 20,
        question: "How long do exchanges typically take to complete?",
        answer: "Exchange duration varies by skill complexity. Simple consultations might take 1-2 hours, while complex projects can span weeks. You'll agree on timeline and deliverables during the negotiation phase.",
        category: "Exchange Process"
    },
    {
        id: 21,
        question: "Can I have multiple active exchanges at the same time?",
        answer: "Yes, you can participate in multiple exchanges simultaneously. However, make sure you can manage your time effectively and fulfill all your commitments to maintain a good reputation on the platform.",
        category: "Exchange Process"
    },
    {
        id: 22,
        question: "What happens when an exchange expires?",
        answer: "Exchanges automatically expire after 30 days of inactivity. Expired exchanges are closed and cannot be reactivated. If you want to continue, you'll need to start a new exchange request.",
        category: "Exchange Process"
    },

    // Skills Management (10 FAQs)
    {
        id: 5,
        question: "How do I add a new skill?",
        answer: "Go to 'My Skills' in your profile and click 'Add Skill'. Fill in the skill title, description, category, level, and any additional details. Make sure to add relevant tags to help others find your skill.",
        category: "Skills Management"
    },
    {
        id: 6,
        question: "How do I edit my existing skills?",
        answer: "In your profile under 'My Skills', find the skill you want to edit and click the 'Edit' button. You can update all details including availability status.",
        category: "Skills Management"
    },
    {
        id: 7,
        question: "What skill categories are available?",
        answer: "Available categories include: Technology, Design, Business, Language, Photography, Music, Handcraft, Education, and Other. Choose the most relevant category for your skill.",
        category: "Skills Management"
    },
    {
        id: 8,
        question: "How do I make my skill unavailable temporarily?",
        answer: "In your skill edit page, you can toggle the 'Available' status to temporarily hide your skill from other users while keeping it in your profile.",
        category: "Skills Management"
    },
    {
        id: 23,
        question: "How do I delete a skill permanently?",
        answer: "In your 'My Skills' section, click on the skill you want to delete, then click 'Edit' and look for the 'Delete Skill' option. Note that skills involved in active exchanges cannot be deleted.",
        category: "Skills Management"
    },
    {
        id: 24,
        question: "Can I duplicate an existing skill listing?",
        answer: "Currently, there's no direct copy feature, but you can create a new skill and manually copy details from an existing one. This is useful for creating variations of similar skills.",
        category: "Skills Management"
    },
    {
        id: 25,
        question: "How do I add images to my skill listing?",
        answer: "When creating or editing a skill, scroll to the 'Images' section and click 'Upload Images'. You can add multiple images to showcase your work, portfolio pieces, or examples of your skill.",
        category: "Skills Management"
    },
    {
        id: 26,
        question: "What makes a good skill description?",
        answer: "A good description is specific, detailed, and explains what you'll deliver. Include your experience level, what the recipient will learn or receive, and any prerequisites. Use keywords others might search for.",
        category: "Skills Management"
    },
    {
        id: 27,
        question: "How do I set an estimated duration for my skill?",
        answer: "In the skill creation form, there's an 'Estimated Duration' field where you can specify how long the skill exchange typically takes (e.g., '2 hours', '1 week project', '3 sessions').",
        category: "Skills Management"
    },
    {
        id: 28,
        question: "Can I offer the same skill multiple times?",
        answer: "Yes, you can create multiple listings for the same skill if you want to offer different packages, levels, or approaches. For example, 'Basic Photography' and 'Advanced Photography Masterclass'.",
        category: "Skills Management"
    },

    // Account Settings (10 FAQs)
    {
        id: 9,
        question: "How do I update my profile information?",
        answer: "Go to Profile > Settings to update your name, bio, location, and other profile details. You can also manage your privacy settings and notification preferences.",
        category: "Account Settings"
    },
    {
        id: 10,
        question: "How do I change my notification preferences?",
        answer: "In Profile > Settings, scroll to the Notifications section. You can toggle email notifications, push notifications, and specific alerts for exchanges and messages.",
        category: "Account Settings"
    },
    {
        id: 11,
        question: "How do I deactivate my account?",
        answer: "In Profile > Settings, scroll to the Account Management section. Click 'Deactivate Account' and confirm. Your account will be hidden but can be reactivated later.",
        category: "Account Settings"
    },
    {
        id: 12,
        question: "How do I change my password?",
        answer: "Since authentication is handled by Supabase, you can reset your password through the login page or your email settings. Look for 'Forgot Password' on the login screen.",
        category: "Account Settings"
    },
    {
        id: 29,
        question: "How do I upload a profile picture?",
        answer: "Go to Profile > Settings and click on your current avatar or the camera icon. Select a new image from your device. Profile pictures help build trust and make your profile more personable.",
        category: "Account Settings"
    },
    {
        id: 30,
        question: "Can I change my email address?",
        answer: "Email changes are handled through Supabase authentication. You'll need to log out and use the 'Change Email' option, or contact support if you're having trouble accessing your account.",
        category: "Account Settings"
    },
    {
        id: 31,
        question: "How do I manage my privacy settings?",
        answer: "In Profile > Settings, find the Privacy section where you can control whether your email and location are visible to other users, and set your overall profile visibility to public or private.",
        category: "Account Settings"
    },
    {
        id: 32,
        question: "What information can other users see about me?",
        answer: "Other users can see your name, bio, skills, location (if enabled), and exchange history. Your email is only visible if you enable it in privacy settings. Your rating and review count are always public.",
        category: "Account Settings"
    },
    {
        id: 33,
        question: "How do I delete my account permanently?",
        answer: "In Profile > Settings, scroll to Account Management and click 'Delete Account'. This permanently removes all your data including skills, exchanges, and messages. This action cannot be undone.",
        category: "Account Settings"
    },
    {
        id: 34,
        question: "Can I reactivate a deactivated account?",
        answer: "Yes, deactivated accounts can be reactivated by simply logging back in. All your data, skills, and exchange history will be restored. Your profile will become visible to other users again.",
        category: "Account Settings"
    },

    // Troubleshooting (10 FAQs)
    {
        id: 13,
        question: "I'm not receiving notifications, what should I do?",
        answer: "Check your notification settings in Profile > Settings. Ensure notifications are enabled for the types you want to receive. Also check your email spam folder for email notifications.",
        category: "Troubleshooting"
    },
    {
        id: 14,
        question: "My exchange is stuck in 'Pending' status, why?",
        answer: "An exchange stays in 'Pending' until the recipient responds. If it's been a while, try messaging them directly or consider that they may not be active on the platform.",
        category: "Troubleshooting"
    },
    {
        id: 15,
        question: "I can't see the chat option in my exchange",
        answer: "Chat is only available when exchanges are in 'Negotiating', 'Pending Acceptance', 'Accepted', or 'In Progress' status. If your exchange is still 'Pending', chat will be enabled once the recipient responds.",
        category: "Troubleshooting"
    },
    {
        id: 16,
        question: "How do I report a problem with another user?",
        answer: "If you encounter issues with another user, try resolving it through the chat feature first. For serious issues, you can contact support through this help center or reach out via email.",
        category: "Troubleshooting"
    },
    {
        id: 35,
        question: "Why can't I find any skills to exchange for?",
        answer: "Try adjusting your search filters, check different categories, or browse without location restrictions. If you're in a small area, consider online delivery methods to access more skills.",
        category: "Troubleshooting"
    },
    {
        id: 36,
        question: "My messages aren't sending in the chat",
        answer: "Check your internet connection, try refreshing the page, or try logging out and back in. If the problem persists, the other user might have connectivity issues or the exchange may be in the wrong status.",
        category: "Troubleshooting"
    },
    {
        id: 37,
        question: "The platform is running slowly or freezing",
        answer: "Try clearing your browser cache, disabling browser extensions, or switching to a different browser. Ensure you have a stable internet connection. Contact support if issues persist.",
        category: "Troubleshooting"
    },
    {
        id: 38,
        question: "I can't upload images to my skill or profile",
        answer: "Ensure your images are under 5MB and in supported formats (JPG, PNG, GIF). Try a different browser or clear your cache. Check that JavaScript is enabled in your browser.",
        category: "Troubleshooting"
    },
    {
        id: 39,
        question: "I accidentally deleted a skill, can I recover it?",
        answer: "Unfortunately, deleted skills cannot be recovered. You'll need to recreate the skill listing. To avoid this in the future, consider making skills 'unavailable' instead of deleting them.",
        category: "Troubleshooting"
    },
    {
        id: 40,
        question: "Why am I not getting any exchange requests?",
        answer: "Ensure your skills are marked as 'available', have detailed descriptions with good keywords, include images if possible, and check that your profile is complete. Consider adjusting your skill offerings or delivery methods.",
        category: "Troubleshooting"
    }
];

// Helper function to get FAQs by category
export const getFAQsByCategory = () => {
    const categories = {};
    helpFAQs.forEach(faq => {
        if (!categories[faq.category]) {
            categories[faq.category] = [];
        }
        categories[faq.category].push(faq);
    });
    return categories;
};

// Helper function to get all categories
export const getCategories = () => {
    return [...new Set(helpFAQs.map(faq => faq.category))];
};

// Helper function to get popular FAQs (most commonly accessed)
export const getPopularFAQs = (limit = 5) => {
    return helpFAQs
        .filter(faq => [1, 2, 5, 9, 13].includes(faq.id)) // Most essential FAQs
        .slice(0, limit);
};

// Helper function to search FAQs
export const searchFAQs = (searchTerm) => {
    if (!searchTerm.trim()) return helpFAQs;

    const term = searchTerm.toLowerCase();
    return helpFAQs.filter(faq =>
        faq.question.toLowerCase().includes(term) ||
        faq.answer.toLowerCase().includes(term) ||
        faq.category.toLowerCase().includes(term)
    );
};





















File: /generate-tree.js

// save this as generate-tree.js in your project root

const fs   = require('fs')
const path = require('path')

// directories to skip
const EXCLUDE = new Set(['node_modules', '.next', 'public', '.git'])
const OUT_FILE = 'tree.txt'

function buildTree(dir, prefix = '') {
  let output = ''
  // read & filter
  const items = fs.readdirSync(dir, { withFileTypes: true })
    .filter(d => !EXCLUDE.has(d.name))
    .sort((a, b) => {
      if (a.isDirectory() && !b.isDirectory()) return -1
      if (!a.isDirectory() && b.isDirectory()) return  1
      return a.name.localeCompare(b.name)
    })

  items.forEach((item, i) => {
    const isLast = i === items.length - 1
    const pointer = isLast ? '└── ' : '├── '
    output += `${prefix}${pointer}${item.name}\n`

    if (item.isDirectory()) {
      const morePrefix = prefix + (isLast ? '    ' : '│   ')
      output += buildTree(path.join(dir, item.name), morePrefix)
    }
  })

  return output
}

// run & write file
const tree = buildTree(process.cwd())
fs.writeFileSync(path.join(process.cwd(), OUT_FILE), tree)
console.log(`✅ tree saved to ./${OUT_FILE}`)





















File: /getcode.js

// combine-files.js

const fs = require('fs');
const path = require('path');

// 1. Hard-coded source directory (change as needed):
const srcDir = path.join(__dirname, '.');

// 2. Output file:
const outFile = path.join(__dirname, 'temp.txt');

// Initialize/clear temp.txt
fs.writeFileSync(outFile, '', 'utf8');

/**
 * Recursively walks `dir`, finds all .js files and
 * appends their path + content + 20 blank lines to temp.txt
 */
function processDir(dir) {
    fs.readdirSync(dir, { withFileTypes: true }).forEach(dirent => {
        const fullPath = path.join(dir, dirent.name);

        if (dirent.isDirectory() &&
            dirent.name !== 'node_modules' &&
            dirent.name !== 'public' &&
            dirent.name !== '.next' && dirent.name !== 'components' && dirent.name !== 'app') {
            processDir(fullPath);
        }
        else if (dirent.isFile() && dirent.name.endsWith('.js')) {
            // compute a POSIX-style relative path for the header
            let rel = path.relative(__dirname, fullPath).replace(/\\/g, '/');
            if (!rel.startsWith('/')) rel = '/' + rel;

            // 2.a Write the location header
            fs.appendFileSync(outFile, `File: ${rel}\n\n`, 'utf8');

            // 2.b Write the file’s contents
            const code = fs.readFileSync(fullPath, 'utf8');
            fs.appendFileSync(outFile, code.trimEnd() + '\n\n', 'utf8');

            // 3. Add 20 blank lines
            fs.appendFileSync(outFile, '\n'.repeat(20), 'utf8');
        }
    });
}

// kick it off
processDir(srcDir);
console.log(`✅ All .js files under "${srcDir}" combined into ${outFile}`);





















File: /hooks/use-user.js

'use client';

import { createClient } from '@/lib/supabase/client';
import { useEffect, useState } from 'react';

export function useUser() {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const supabase = createClient();

    // Fetch user data from MongoDB
    const fetchUserFromMongoDB = async () => {
        try {
            setError(null);
            const response = await fetch('/api/user/sync', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            });

            if (!response.ok) {
                if (response.status === 401) {
                    // User not authenticated
                    setUser(null);
                    return;
                }
                throw new Error('Failed to fetch user data');
            }

            const { user: mongoUser } = await response.json();
            setUser(mongoUser);
        } catch (error) {
            console.error('Error fetching user from MongoDB:', error);
            setError(error.message);
            setUser(null);
        }
    };

    useEffect(() => {
        // Get initial session quickly from localStorage (no network)
        const getUser = async () => {
            try {
                // Use getSession for faster local check
                const { data: { session } } = await supabase.auth.getSession();
                const supabaseUser = session?.user;

                if (supabaseUser) {
                    // User is authenticated, fetch full data from MongoDB
                    await fetchUserFromMongoDB();
                } else {
                    // User not authenticated
                    setUser(null);
                }
            } catch (error) {
                console.error('Error getting initial user:', error);
                setError(error.message);
                setUser(null);
            } finally {
                setLoading(false);
            }
        };

        getUser();

        // Listen for auth state changes (login/logout)
        const { data: { subscription } } = supabase.auth.onAuthStateChange(
            async (event, session) => {
                try {
                    setLoading(true);
                    setError(null);

                    if (event === 'SIGNED_OUT' || !session?.user) {
                        // User signed out
                        setUser(null);
                    } else if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED' || event === 'INITIAL_SESSION') {
                        // User signed in or token refreshed, fetch MongoDB data
                        await fetchUserFromMongoDB();
                    }
                } catch (error) {
                    console.error('Auth state change error:', error);
                    setError(error.message);
                } finally {
                    setLoading(false);
                }
            }
        );

        // Cleanup subscription on component unmount
        return () => subscription.unsubscribe();
    }, [supabase.auth]);

    // Refresh user data (useful for profile updates)
    const refreshUser = async () => {
        setLoading(true);
        await fetchUserFromMongoDB();
        setLoading(false);
    };

    return {
        user,        // MongoDB user object with full profile data
        loading,
        error,
        refreshUser  // Function to manually refresh user data
    };
}





















File: /hooks/useAdminCheck.js

// hooks/useAdminCheck.js
'use client';

import { useRouter } from 'next/navigation';
import { useEffect, useState } from 'react';

export function useAdminCheck() {
    const router = useRouter();
    const [isAdmin, setIsAdmin] = useState(false);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const checkAdminStatus = async () => {
            try {
                const response = await fetch('/api/admin/check');
                if (response.ok) {
                    const data = await response.json();
                    setIsAdmin(data.isAdmin);
                } else {
                    router.push('/');
                }
            } catch (error) {
                console.error('Error checking admin status:', error);
                router.push('/');
            } finally {
                setLoading(false);
            }
        };

        checkAdminStatus();
    }, [router]);

    return { isAdmin, loading };
}





















File: /hooks/useExchangeChat.js

// hooks/useExchangeChat.js

'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import { useExchangeSocket } from '@/lib/socket';
import { validateMessageContent, isDuplicateMessage, generateTempMessageId } from '@/utils/exchangeChatHelpers';

export function useExchangeChat(exchangeId, currentUser) {
    // Core state
    const [messages, setMessages] = useState([]);
    const [connectionStatus, setConnectionStatus] = useState('disconnected');
    const [error, setError] = useState(null);
    const [otherUserTyping, setOtherUserTyping] = useState(false);
    const [loading, setLoading] = useState(false);

    // Refs for non-rendering values
    const socketManagerRef = useRef(null);
    const typingTimeoutRef = useRef(null);
    const isTypingRef = useRef(false);

    // Initialize socket manager
    if (!socketManagerRef.current) {
        socketManagerRef.current = useExchangeSocket();
    }

    // Load messages from API
    const loadMessages = useCallback(async () => {
        if (!exchangeId) return;

        setLoading(true);
        try {
            const response = await fetch(`/api/exchanges/${exchangeId}/messages`, {cache: 'no-store'});
            const data = await response.json();

            if (data.success) {
                // Simple timestamp-based sorting
                const sortedMessages = data.messages.sort((a, b) => {
                    return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime();
                });
                setMessages(sortedMessages);
            } else {
                setError(data.error || 'Failed to load messages');
            }
        } catch (err) {
            console.error('Error loading messages:', err);
            setError('Failed to load messages');
        } finally {
            setLoading(false);
        }
    }, [exchangeId]);

    // Send message
    const sendMessage = useCallback(async (content) => {
        const validation = validateMessageContent(content);
        if (!validation.isValid) {
            setError(validation.error);
            return false;
        }

        const tempId = generateTempMessageId();

        // Optimistic update
        const optimisticMessage = {
            _id: tempId,
            content: validation.trimmedContent,
            type: 'user',
            sender: {
                supabaseId: currentUser.supabaseId,
                role: 'unknown'
            },
            createdAt: new Date(),
            readBy: [{ supabaseId: currentUser.supabaseId }],
            status: 'sending'
        };

        setMessages(prev => [...prev, optimisticMessage]);

        try {
            const socketSent = socketManagerRef.current?.isReady();

            if (socketSent) {
                // Prefer socket: saves on server & broadcasts, avoids double-write
                socketManagerRef.current.sendExchangeMessage(
                    exchangeId,
                    validation.trimmedContent,
                    tempId
                );

                // Success will be reflected when `message-delivered` comes back
                return true;
            }

            // Fallback to REST API when socket not connected
            const response = await fetch(`/api/exchanges/${exchangeId}/messages`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ content: validation.trimmedContent }),
                cache: 'no-store'
            });
            const data = await response.json();

            if (data.success) {
                setMessages(prev =>
                    prev.map(msg =>
                        msg._id === tempId ? { ...data.message, status: 'sent' } : msg
                    )
                );
                return true;
            }

            throw new Error(data.error || 'Failed to send');
        } catch (error) {
            console.error('Error sending message:', error);

            // Mark message as failed
            setMessages(prev =>
                prev.map(msg =>
                    msg._id === tempId
                        ? { ...msg, status: 'failed' }
                        : msg
                )
            );

            setError('Failed to send message');
            return false;
        }
    }, [exchangeId, currentUser?.supabaseId]);

    // Typing indicators
    const startTyping = useCallback(() => {
        if (!isTypingRef.current && connectionStatus === 'connected') {
            isTypingRef.current = true;
            socketManagerRef.current.startTyping();
        }

        if (typingTimeoutRef.current) {
            clearTimeout(typingTimeoutRef.current);
        }

        typingTimeoutRef.current = setTimeout(() => {
            stopTyping();
        }, 3000);
    }, [connectionStatus]);

    const stopTyping = useCallback(() => {
        if (isTypingRef.current) {
            isTypingRef.current = false;
            socketManagerRef.current.stopTyping();
        }

        if (typingTimeoutRef.current) {
            clearTimeout(typingTimeoutRef.current);
            typingTimeoutRef.current = null;
        }
    }, []);

    // Mark messages as read
    const markAsRead = useCallback(async () => {
        try {
            await fetch(`/api/exchanges/${exchangeId}/mark-read`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' }
            });
        } catch (error) {
            console.error('Error marking messages as read:', error);
        }
    }, [exchangeId]);

    // Connect to exchange chat
    const connectToExchange = useCallback(async () => {
        const socketManager = socketManagerRef.current;

        try {
            // Check if chat is available
            const statusRes = await fetch(`/api/exchanges/${exchangeId}/chat-status`);
            const statusData = await statusRes.json();

            if (!statusData.success || !statusData.chatStatus.available) {
                setError(statusData.error || statusData.chatStatus.message || 'Chat not available');
                setConnectionStatus('disconnected');
                return;
            }

            // Connect socket
            await socketManager.connect();
            socketManager.joinExchangeChat(exchangeId);

            setConnectionStatus('connected');
            setError(null);

        } catch (error) {
            console.error('Connection failed:', error);
            setConnectionStatus('disconnected');
            setError('Failed to connect to chat');
        }
    }, [exchangeId]);

    // Load messages on mount
    useEffect(() => {
        loadMessages();
    }, [loadMessages]);

    // Connect to socket on mount
    useEffect(() => {
        connectToExchange();

        return () => {
            socketManagerRef.current?.leaveExchangeChat();
        };
    }, [connectToExchange]);

    // Socket event handlers
    useEffect(() => {
        const socketManager = socketManagerRef.current;
        if (!socketManager?.isReady()) return;

        // Handle new messages from other users
        const handleNewMessage = (messageData) => {
            if (messageData.sender.supabaseId !== currentUser?.supabaseId) {
                // Simple duplicate check by ID
                if (!isDuplicateMessage(messageData, messages)) {
                    setMessages(prev => [...prev, { ...messageData, status: 'received' }]);

                    // Auto-mark as read after a short delay
                    setTimeout(markAsRead, 1000);
                }
            }
        };

        // Handle message delivery confirmation
        const handleMessageDelivered = (data) => {
            if (data.tempId) {
                setMessages(prev =>
                    prev.map(msg =>
                        msg._id === data.tempId
                            ? { ...msg, _id: data.messageId, status: 'delivered' }
                            : msg
                    )
                );
            }
        };

        // Handle typing indicators
        const handleTyping = (typingData) => {
            if (typingData.userSupabaseId !== currentUser?.supabaseId) {
                setOtherUserTyping(typingData.isTyping);
            }
        };

        // Handle chat closed
        const handleChatClosed = (data) => {
            setError(`Chat closed: ${data.reason}`);
            setConnectionStatus('disconnected');
        };

        // Handle chat errors
        const handleChatError = (error) => {
            setError(error.message || 'Chat error occurred');
            setConnectionStatus('disconnected');
        };

        // Handle connection events
        const handleDisconnect = () => {
            setConnectionStatus('disconnected');
            setError('Disconnected from chat');
        };

        const handleReconnect = () => {
            setConnectionStatus('connected');
            setError(null);
            loadMessages(); // Refresh messages on reconnect
        };

        // Attach event listeners
        socketManager.onNewExchangeMessage(handleNewMessage);
        socketManager.onMessageDelivered(handleMessageDelivered);
        socketManager.onUserTyping(handleTyping);
        socketManager.onChatClosed(handleChatClosed);
        socketManager.onChatError(handleChatError);

        socketManager.socket?.on('disconnect', handleDisconnect);
        socketManager.socket?.on('reconnect', handleReconnect);

        return () => {
            // Cleanup event listeners
            socketManager.offNewExchangeMessage(handleNewMessage);
            socketManager.offMessageDelivered(handleMessageDelivered);
            socketManager.offUserTyping(handleTyping);
            socketManager.offChatClosed(handleChatClosed);
            socketManager.offChatError(handleChatError);

            socketManager.socket?.off('disconnect', handleDisconnect);
            socketManager.socket?.off('reconnect', handleReconnect);
        };
    }, [currentUser?.supabaseId, messages, markAsRead, loadMessages]);

    // Cleanup on unmount
    useEffect(() => {
        return () => {
            stopTyping();
            if (typingTimeoutRef.current) {
                clearTimeout(typingTimeoutRef.current);
            }
        };
    }, [stopTyping]);

    return {
        // State
        messages,
        connectionStatus,
        error,
        otherUserTyping,
        loading,

        // Actions
        sendMessage,
        startTyping,
        stopTyping,
        markAsRead,
        loadMessages,

        // Utils
        isConnected: connectionStatus === 'connected',
        hasError: !!error,
        clearError: () => setError(null),
        retryConnection: connectToExchange
    };
}





















File: /lib/analytics.js

import SkillView from '@/models/SkillView';
import connectDB from '@/lib/mongodb';

/**
 * Log a skill view event
 * @param {string} skillId - MongoDB ObjectId of the skill
 * @param {string|null} viewerSupabaseId - Supabase ID of viewer (null for anonymous)
 * @param {Object} request - Next.js request object for IP/headers
 */
export async function logSkillView(skillId, viewerSupabaseId = null, request = null) {
    try {
        await connectDB();

        // Get IP address and user agent from request
        let ipAddress = '127.0.0.1'; // Default fallback
        let userAgent = 'Unknown';

        if (request) {
            // Try to get real IP address
            ipAddress =
                request.headers.get('x-forwarded-for')?.split(',')[0] ||
                request.headers.get('x-real-ip') ||
                request.headers.get('cf-connecting-ip') ||
                '127.0.0.1';

            userAgent = request.headers.get('user-agent') || 'Unknown';
        }

        // Create the view record
        const skillView = new SkillView({
            skillId,
            viewerSupabaseId,
            ipAddress,
            userAgent,
            viewDate: new Date()
        });

        await skillView.save();

        // Also increment the total view count on the skill
        const { default: Skill } = await import('@/models/Skill');
        await Skill.findByIdAndUpdate(
            skillId,
            { $inc: { viewCount: 1 } },
            { new: true }
        );

        return { success: true };

    } catch (error) {
        console.error('Error logging skill view:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Check if this is likely a unique view (prevent spam/bot inflation)
 * @param {string} skillId 
 * @param {string} ipAddress 
 * @param {string|null} viewerSupabaseId 
 * @returns {boolean} True if this should be counted as a view
 */
export async function shouldCountView(skillId, ipAddress, viewerSupabaseId = null) {
    try {
        await connectDB();

        // Check for recent views from same source (last 5 minutes)
        const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);

        const query = {
            skillId,
            viewDate: { $gte: fiveMinutesAgo }
        };

        // If user is logged in, check by user ID, otherwise by IP
        if (viewerSupabaseId) {
            query.viewerSupabaseId = viewerSupabaseId;
        } else {
            query.ipAddress = ipAddress;
            query.viewerSupabaseId = null; // Ensure it's anonymous
        }

        const recentView = await SkillView.findOne(query);

        return !recentView; // Return true if no recent view found

    } catch (error) {
        console.error('Error checking view uniqueness:', error);
        return true; // Default to counting the view if check fails
    }
}





















File: /lib/gemini.js

// lib/geminiService.js

// NOTE: We intentionally avoid importing the Gemini SDK at the top-level so that
// this file can be safely bundled for the browser (e.g. when only QUICK_ACTIONS
// is imported).  The SDK is instead loaded lazily inside `getChatResponse`,
// ensuring it is only executed in a server environment where the API key is
// available.




// Platform-specific system prompt (same as before)
const SYSTEM_PROMPT = `You are an AI assistant for a Skill Barter System platform. Help users with platform-specific questions using this context:

PLATFORM OVERVIEW:
- Users can offer skills in exchange for other skills or money
- Two main exchange types: skill_for_skill and skill_for_money
- Users create profiles, add skills, and engage in exchanges

EXCHANGE PROCESS:
- Status flow: pending → negotiating → pending_acceptance → accepted → in_progress → completed
- Two-step acceptance system: both parties must accept before proceeding
- Chat/messaging available during negotiating, pending_acceptance, accepted, and in_progress statuses
- Negotiation features allow setting deliverables, deadlines, and terms

SKILLS MANAGEMENT:
- Categories: Technology, Design, Business, Language, Photography, Music, Handcraft, Education, Other
- Levels: Beginner, Intermediate, Advanced, Expert
- Users can set availability status and delivery methods (In-person, Online, Both)
- Skills have descriptions, tags, and estimated duration

ACCOUNT FEATURES:
- Profile management with bio, location, avatar
- Privacy settings for email/location visibility
- Notification preferences for exchanges and messages
- Account deactivation/reactivation options

PROVIDE SPECIFIC, ACTIONABLE ANSWERS:
- Use platform terminology exactly as described
- Give step-by-step instructions when possible
- Reference specific page paths (e.g., "Profile > Settings")
- If unsure, suggest checking the FAQ section or contacting support

Keep responses concise but helpful, focusing on solving the user's immediate need.`;

// Quick action prompts (same as before)
export const QUICK_ACTIONS = [
    {
        id: 'start-exchange',
        text: 'How do I start an exchange?',
        prompt: 'How do I start an exchange on this platform?'
    },
    {
        id: 'add-skill',
        text: 'How do I add a new skill?',
        prompt: 'How do I add a new skill to my profile?'
    },
    {
        id: 'negotiation',
        text: 'How does negotiation work?',
        prompt: 'How does the negotiation process work for exchanges?'
    },
    {
        id: 'update-profile',
        text: 'How do I update my profile?',
        prompt: 'How do I update my profile information and settings?'
    },
    {
        id: 'exchange-status',
        text: 'What are the exchange statuses?',
        prompt: 'What are the different exchange statuses and what do they mean?'
    }
];

// Updated main chat function using new API structure
export async function getChatResponse(userMessage, conversationHistory = []) {
    // Dynamically import the SDK to avoid loading it in the browser bundle
    const { GoogleGenAI } = await import('@google/genai');

    // Fail fast if API key is missing (additional guard besides validateGeminiAPI)
    if (!process.env.GEMINI_API_KEY) {
        throw new Error('GEMINI_API_KEY is not set.');
    }

    const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });
    try {
        // Build conversation context with system instruction
        const conversationContext = conversationHistory.length > 0
            ? `${SYSTEM_PROMPT}\n\nPrevious conversation:\n${conversationHistory.map(msg =>
                `${msg.role}: ${msg.content}`
            ).join('\n')}\n\nUser: ${userMessage}`
            : `${SYSTEM_PROMPT}\n\nUser: ${userMessage}`;

        // Generate response using new API structure
        const response = await ai.models.generateContent({
            model: "gemini-2.0-flash",
            contents: conversationContext
        });

        return {
            success: true,
            response: response.text,
            timestamp: new Date().toISOString()
        };

    } catch (error) {
        console.error('Gemini API error:', error);

        // Return fallback response
        return {
            success: false,
            response: "I'm having trouble connecting to my AI service right now. Please try again in a moment, or check our FAQ section for common questions.",
            error: error.message,
            timestamp: new Date().toISOString()
        };
    }
}

// Helper function to validate API key (same as before)
export function validateGeminiAPI() {
    return !!process.env.GEMINI_API_KEY;
}





















File: /lib/mongodb.js

import mongoose from 'mongoose';


let cached = global.mongoose;

if (!cached) {
    cached = global.mongoose = { conn: null, promise: null };
}

async function connectDB() {
    const MONGODB_URI = process.env.MONGODB_URI;
    
    if (!MONGODB_URI) {
        throw new Error('Please define the MONGODB_URI environment variable');
    }
    if (cached.conn) {
        return cached.conn;
    }

    if (!cached.promise) {
        const opts = {
            bufferCommands: false,
        };

        cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {
            console.log('Connected to MongoDB');
            return mongoose;
        });
    }

    try {
        cached.conn = await cached.promise;
    } catch (e) {
        cached.promise = null;
        throw e;
    }

    return cached.conn;
}

export default connectDB;





















File: /lib/socket.js

// lib/socket.js

'use client';

import { io } from 'socket.io-client';
import { createClient } from '@/lib/supabase/client';

class ExchangeSocketManager {
    constructor() {
        this.socket = null;
        this.currentExchangeId = null;
        this.currentUser = null;
        this.isConnected = false;
        this.connectionAttempts = 0;
        this.userRole = null; // 'initiator' or 'recipient'
    }

    // Initialize socket connection
    async connect() {
        if (this.socket?.connected) return this.socket;

        try {
            // Get current user for authentication
            const supabase = createClient();
            const { data: { user } } = await supabase.auth.getUser();

            if (!user) {
                throw new Error('User not authenticated');
            }

            this.currentUser = user;

            // Connect to Socket.IO server
            this.socket = io(process.env.NODE_ENV === 'production'
                ? process.env.NEXT_PUBLIC_SITE_URL
                : 'http://localhost:3000', {
                autoConnect: true,
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 1000
            });

            // Setup event listeners
            this.setupEventListeners();

            return this.socket;

        } catch (error) {
            console.error('Socket connection failed:', error);
            throw error;
        }
    }

    // Setup socket event listeners
    setupEventListeners() {
        if (!this.socket) return;

        // Connection events
        this.socket.on('connect', () => {
            console.log('Exchange socket connected:', this.socket.id);
            this.isConnected = true;
            this.connectionAttempts = 0;

            // Rejoin current exchange if we were in one
            if (this.currentExchangeId) {
                this.joinExchangeChat(this.currentExchangeId);
            }
        });

        this.socket.on('disconnect', () => {
            console.log('Exchange socket disconnected');
            this.isConnected = false;
        });

        this.socket.on('connect_error', (error) => {
            console.error('Socket connection error:', error);
            this.isConnected = false;
            this.connectionAttempts++;
        });

        this.socket.on('reconnect', (attemptNumber) => {
            console.log('Socket reconnected after', attemptNumber, 'attempts');
            this.isConnected = true;
            this.connectionAttempts = 0;
        });

        // Error handling
        this.socket.on('error', (error) => {
            console.error('Socket error:', error);
        });

        this.socket.on('chat-error', (error) => {
            console.error('Exchange chat error:', error.message || 'Unknown chat error');
        });
    }

    // Join exchange chat
    joinExchangeChat(exchangeId) {
        if (!this.socket || !this.currentUser) {
            console.error('Socket not connected or user not authenticated');
            return false;
        }

        // Leave current exchange chat if different
        if (this.currentExchangeId && this.currentExchangeId !== exchangeId) {
            this.leaveExchangeChat();
        }

        this.currentExchangeId = exchangeId;
        this.socket.emit('join-exchange-chat', {
            exchangeId,
            userSupabaseId: this.currentUser.id
        });

        console.log(`Joining exchange chat: ${exchangeId}`);
        return true;
    }

    // Leave exchange chat
    leaveExchangeChat() {
        if (!this.socket || !this.currentExchangeId) return false;

        this.socket.emit('leave-exchange-chat');
        console.log(`Left exchange chat: ${this.currentExchangeId}`);

        this.currentExchangeId = null;
        this.userRole = null;
        return true;
    }

    // Send exchange message
    sendExchangeMessage(exchangeId, content, tempId = null) {
        if (!this.socket || !this.currentUser) {
            console.error('Cannot send message: Socket not connected');
            return false;
        }

        if (!content.trim()) {
            console.error('Cannot send empty message');
            return false;
        }

        if (!exchangeId) {
            console.error('Missing exchangeId');
            return false;
        }

        this.socket.emit('send-exchange-message', {
            exchangeId,
            content: content.trim(),
            messageId: tempId // For delivery confirmation
        });

        return true;
    }

    // Notify offer update for real-time updates
    notifyOfferUpdate(exchangeId, offerType, newOffer) {
        if (!this.socket || !this.currentUser) {
            console.error('Cannot notify offer update: Socket not connected');
            return false;
        }

        this.socket.emit('offer-updated', {
            exchangeId,
            offerType, // 'initiator' or 'recipient'
            newOffer,
            userSupabaseId: this.currentUser.id
        });

        return true;
    }

    // NEW: Notify negotiation field update (triggers notification button)
    notifyNegotiationFieldUpdate(exchangeId, fieldName, userRole) {
        if (!this.socket || !this.currentUser) {
            console.error('Cannot notify negotiation update: Socket not connected');
            return false;
        }

        this.socket.emit('negotiation-field-updated', {
            exchangeId,
            fieldName,
            userRole,
            userSupabaseId: this.currentUser.id,
            timestamp: new Date().toISOString()
        });

        return true;
    }

    // NEW: Notify negotiation agreement update
    notifyNegotiationAgreement(exchangeId, agreed, userRole) {
        if (!this.socket || !this.currentUser) {
            console.error('Cannot notify agreement update: Socket not connected');
            return false;
        }

        this.socket.emit('negotiation-agreement-updated', {
            exchangeId,
            agreed,
            userRole,
            userSupabaseId: this.currentUser.id,
            timestamp: new Date().toISOString()
        });

        return true;
    }

    // NEW: Notify negotiation status change
    notifyNegotiationStatusChange(exchangeId, newStatus, previousStatus) {
        if (!this.socket || !this.currentUser) {
            console.error('Cannot notify status change: Socket not connected');
            return false;
        }

        this.socket.emit('negotiation-status-changed', {
            exchangeId,
            newStatus,
            previousStatus,
            userSupabaseId: this.currentUser.id,
            timestamp: new Date().toISOString()
        });

        return true;
    }

    // Notify status change for real-time updates
    notifyStatusChange(exchangeId, newStatus, previousStatus, acceptanceData = null) {
        if (!this.socket || !this.currentUser) {
            console.error('Cannot notify status change: Socket not connected');
            return false;
        }

        this.socket.emit('status-changed', {
            exchangeId,
            newStatus,
            previousStatus,
            acceptanceData, // Include acceptance data
            userSupabaseId: this.currentUser.id
        });

        return true;
    }

    // Notify user acceptance for real-time updates
    notifyUserAcceptance(exchangeId, newStatus, acceptanceData, message) {
        if (!this.socket || !this.currentUser) {
            console.error('Cannot notify user acceptance: Socket not connected');
            return false;
        }

        this.socket.emit('user-accepted', {
            exchangeId,
            userSupabaseId: this.currentUser.id,
            newStatus,
            acceptanceData,
            message
        });

        return true;
    }

    // Typing indicators
    startTyping() {
        if (!this.socket || !this.currentExchangeId) return false;
        this.socket.emit('typing-start');
        return true;
    }

    stopTyping() {
        if (!this.socket || !this.currentExchangeId) return false;
        this.socket.emit('typing-stop');
        return true;
    }

    // Check if connected and ready
    isReady() {
        return this.isConnected && this.socket && this.currentUser;
    }

    // Get current exchange info
    getCurrentExchange() {
        return {
            exchangeId: this.currentExchangeId,
            userRole: this.userRole
        };
    }

    // Get current user info
    getCurrentUser() {
        return this.currentUser;
    }

    // Event listeners for components

    // New exchange message received
    onNewExchangeMessage(callback) {
        if (!this.socket) return false;
        this.socket.on('new-exchange-message', callback);
        return true;
    }

    // Message delivery confirmation
    onMessageDelivered(callback) {
        if (!this.socket) return false;
        this.socket.on('message-delivered', callback);
        return true;
    }

    // Real-time offer updates (for negotiation playground)
    onOfferUpdated(callback) {
        if (!this.socket) return false;
        this.socket.on('offer-updated-realtime', callback);
        return true;
    }

    // Real-time status changes
    onStatusChanged(callback) {
        if (!this.socket) return false;
        this.socket.on('status-changed-realtime', callback);
        return true;
    }

    // Real-time user acceptance events
    onUserAcceptedExchange(callback) {
        if (!this.socket) return false;
        this.socket.on('user-accepted-exchange', callback);
        return true;
    }

    // NEW: Negotiation field updates (triggers notification button)
    onNegotiationFieldUpdated(callback) {
        if (!this.socket) return false;
        this.socket.on('negotiation-field-updated', callback);
        return true;
    }

    // NEW: Negotiation agreement updates
    onNegotiationAgreementUpdated(callback) {
        if (!this.socket) return false;
        this.socket.on('negotiation-agreement-updated', callback);
        return true;
    }

    // NEW: Negotiation status changes
    onNegotiationStatusChanged(callback) {
        if (!this.socket) return false;
        this.socket.on('negotiation-status-changed', callback);
        return true;
    }

    // User typing indicators
    onUserTyping(callback) {
        if (!this.socket) return false;
        this.socket.on('user-typing', callback);
        return true;
    }

    // Chat closed (exchange ended)
    onChatClosed(callback) {
        if (!this.socket) return false;
        this.socket.on('chat-closed', callback);
        return true;
    }

    // Chat error handling
    onChatError(callback) {
        if (!this.socket) return false;
        this.socket.on('chat-error', callback);
        return true;
    }

    // Remove event listeners
    offNewExchangeMessage(callback) {
        if (!this.socket) return false;
        this.socket.off('new-exchange-message', callback);
        return true;
    }

    offMessageDelivered(callback) {
        if (!this.socket) return false;
        this.socket.off('message-delivered', callback);
        return true;
    }

    offOfferUpdated(callback) {
        if (!this.socket) return false;
        this.socket.off('offer-updated-realtime', callback);
        return true;
    }

    offStatusChanged(callback) {
        if (!this.socket) return false;
        this.socket.off('status-changed-realtime', callback);
        return true;
    }

    // Remove user acceptance event listeners
    offUserAcceptedExchange(callback) {
        if (!this.socket) return false;
        this.socket.off('user-accepted-exchange', callback);
        return true;
    }

    // NEW: Remove negotiation event listeners
    offNegotiationFieldUpdated(callback) {
        if (!this.socket) return false;
        this.socket.off('negotiation-field-updated', callback);
        return true;
    }

    offNegotiationAgreementUpdated(callback) {
        if (!this.socket) return false;
        this.socket.off('negotiation-agreement-updated', callback);
        return true;
    }

    offNegotiationStatusChanged(callback) {
        if (!this.socket) return false;
        this.socket.off('negotiation-status-changed', callback);
        return true;
    }

    offUserTyping(callback) {
        if (!this.socket) return false;
        this.socket.off('user-typing', callback);
        return true;
    }

    offChatClosed(callback) {
        if (!this.socket) return false;
        this.socket.off('chat-closed', callback);
        return true;
    }

    offChatError(callback) {
        if (!this.socket) return false;
        this.socket.off('chat-error', callback);
        return true;
    }

    // Get connection status
    getStatus() {
        return {
            isConnected: this.isConnected,
            currentExchangeId: this.currentExchangeId,
            userRole: this.userRole,
            currentUser: this.currentUser,
            socketId: this.socket?.id,
            connectionAttempts: this.connectionAttempts,
            isReady: this.isReady()
        };
    }

    // Disconnect socket
    disconnect() {
        if (this.socket) {
            // Leave current exchange chat before disconnect
            if (this.currentExchangeId) {
                this.leaveExchangeChat();
            }

            this.socket.disconnect();
            this.socket = null;
            this.currentExchangeId = null;
            this.userRole = null;
            this.isConnected = false;
            this.connectionAttempts = 0;
            console.log('Exchange socket disconnected manually');
        }
    }
}

// Create singleton instance
const exchangeSocketManager = new ExchangeSocketManager();

export default exchangeSocketManager;

// Export hook for easy usage in components
export const useExchangeSocket = () => {
    return exchangeSocketManager;
};





















File: /lib/supabase/client.js

import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
    return createBrowserClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
    );
}





















File: /lib/supabase/server.js

import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createClient() {
    const cookieStore = await cookies();

    return createServerClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
        {
            cookies: {
                getAll() {
                    return cookieStore.getAll();
                },
                setAll(cookiesToSet) {
                    try {
                        cookiesToSet.forEach(({ name, value, options }) =>
                            cookieStore.set(name, value, options)
                        );
                    } catch {
                        // ignore if middleware managing sessions
                    }
                },
            },
        }
    );
}





















File: /middleware.js

// middleware.js
import { createServerClient } from '@supabase/ssr';
import { NextResponse } from 'next/server';

export async function middleware(request) {
    // Create response object
    let response = NextResponse.next({
        request: {
            headers: request.headers,
        },
    });

    // Create Supabase client for middleware
    const supabase = createServerClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
        {
            cookies: {
                getAll() {
                    return request.cookies.getAll();
                },
                setAll(cookiesToSet) {
                    cookiesToSet.forEach(({ name, value, options }) => {
                        request.cookies.set(name, value);
                        response.cookies.set(name, value, options);
                    });
                },
            },
        }
    );

    // Get current user session
    const { data: { user } } = await supabase.auth.getUser();

    const { pathname } = request.nextUrl;

    // Admin routes protection - only check authentication here
    if (pathname.startsWith('/admin')) {
        if (!user) {
            // Redirect to auth page if not logged in
            return NextResponse.redirect(new URL('/auth', request.url));
        }
        // Admin status will be checked in the actual admin pages/APIs
    }

    // Define protected routes (routes that need authentication)
    const protectedRoutes = ['/my-skills', '/exchanges', '/profile'];
    const isProtectedRoute = protectedRoutes.some(route => pathname.startsWith(route));

    // Define auth routes (routes for login/signup)
    const authRoutes = ['/auth'];
    const isAuthRoute = authRoutes.some(route => pathname.startsWith(route));

    // Redirect unauthenticated users from protected routes to auth
    if (isProtectedRoute && !user) {
        return NextResponse.redirect(new URL('/auth', request.url));
    }

    // Redirect authenticated users from auth routes to dashboard
    if (isAuthRoute && user) {
        return NextResponse.redirect(new URL('/profile', request.url));
    }

    return response;
}

export const config = {
    matcher: [
        /*
         * Match all request paths except:
         * - _next/static (static files)
         * - _next/image (image optimization files)
         * - favicon.ico (favicon file)
         * - public files (images, etc.)
         * - API routes
         */
        '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$|api/).*)',
    ],
};





















File: /models/Dispute.js

// models/Dispute.js
import mongoose from 'mongoose';

const disputeSchema = new mongoose.Schema({
    // Core dispute information
    disputeId: {
        type: String,
        unique: true,
        required: true,
        default: () => `DISP-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`
    },

    // Associated exchange
    exchangeId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Exchange',
        required: true
    },

    // Who raised the dispute - simplified to just userId
    raisedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },

    // Simple text description and evidence
    description: {
        type: String,
        required: true,
        maxLength: 1000
    },

    // Evidence as simple text field
    evidence: {
        type: String,
        maxLength: 2000
    },

    // Simple status - only open and resolved
    status: {
        type: String,
        enum: ['open', 'resolved'],
        default: 'open'
    },

    // Who resolved it - admin userId
    resolvedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    },

    // Admin resolution details
    resolution: {
        decision: String,
        reasoning: String,
        resolvedAt: Date
    }
}, {
    timestamps: true
});

// Indexes for admin queries
disputeSchema.index({ status: 1, createdAt: -1 });
disputeSchema.index({ exchangeId: 1 });
disputeSchema.index({ raisedBy: 1 });

export default mongoose.models.Dispute || mongoose.model('Dispute', disputeSchema);





















File: /models/Exchange.js

// models/Exchange.js
import mongoose from 'mongoose';

const exchangeSchema = new mongoose.Schema({
    // Basic Exchange Information
    exchangeId: {
        type: String,
        unique: true,
        required: true,
        default: () => `EXC-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`
    },

    // Participants
    initiator: {
        userId: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'User',
            required: true
        },
        supabaseId: {
            type: String,
            required: true
        }
    },
    recipient: {
        userId: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'User',
            required: true
        },
        supabaseId: {
            type: String,
            required: true
        }
    },

    // UPDATED: Exchange Type (simplified from 3 to 2 types)
    exchangeType: {
        type: String,
        enum: ['skill_for_skill', 'skill_for_money'],
        required: true
    },

    // Initiator's Offer (KEEPING ALL ORIGINAL FIELDS)
    initiatorOffer: {
        type: {
            type: String,
            enum: ['skill', 'money'],
            required: true
        },
        skillId: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Skill'
        },
        skillTitle: String,
        monetaryAmount: {
            type: Number,
            min: [0, 'Amount cannot be negative']
        },
        currency: {
            type: String,
            default: 'USD',
            enum: ['USD', 'EUR', 'GBP', 'INR']
        },
        description: {
            type: String,
            required: true,
            maxLength: [1000, 'Description cannot exceed 1000 characters'],
            trim: true
        },
        estimatedHours: Number,
        deliveryDate: Date,
        deliveryMethod: {
            type: String,
            enum: ['In-person', 'Online', 'Both'],
            required: true
        }
    },

    // Recipient's Offer (KEEPING ALL ORIGINAL FIELDS)
    recipientOffer: {
        type: {
            type: String,
            enum: ['skill', 'money'],
            required: true
        },
        skillId: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Skill'
        },
        skillTitle: String,
        monetaryAmount: {
            type: Number,
            min: [0, 'Amount cannot be negative']
        },
        currency: {
            type: String,
            default: 'USD',
            enum: ['USD', 'EUR', 'GBP', 'INR']
        },
        description: {
            type: String,
            maxLength: [1000, 'Description cannot exceed 1000 characters'],
            trim: true
        },
        estimatedHours: Number,
        deliveryDate: Date,
        deliveryMethod: {
            type: String,
            enum: ['In-person', 'Online', 'Both']
        }
    },

    // Two-Step Acceptance System
    acceptance: {
        initiatorAccepted: {
            type: Boolean,
            default: false
        },
        recipientAccepted: {
            type: Boolean,
            default: false
        },
        initiatorAcceptedAt: Date,
        recipientAcceptedAt: Date,
        fullyAcceptedAt: Date // When both users have accepted
    },

    // Exchange Status
    status: {
        type: String,
        enum: [
            'pending',
            'negotiating',
            'pending_acceptance', // One user accepted, waiting for other
            'accepted',           // Both users accepted
            'in_progress',
            'completed',
            'cancelled',
            'expired'
        ],
        default: 'pending'
    },

    // Payment and Escrow
    payment: {
        escrowAmount: {
            type: Number,
            min: 0
        },
        escrowStatus: {
            type: String,
            enum: ['none', 'pending', 'held', 'released', 'refunded'],
            default: 'none'
        },
        transactionId: String
    },

    // Delivery Status
    delivery: {
        initiatorDelivered: {
            type: Boolean,
            default: false
        },
        recipientDelivered: {
            type: Boolean,
            default: false
        },
        initiatorDeliveredAt: Date,
        recipientDeliveredAt: Date,
        deliveryNotes: {
            initiator: String,
            recipient: String
        }
    },

    // Rating and Feedback
    feedback: {
        initiatorRating: {
            rating: {
                type: Number,
                min: 1,
                max: 5
            },
            review: {
                type: String,
                maxLength: [500, 'Review cannot exceed 500 characters']
            },
            ratedAt: Date
        },
        recipientRating: {
            rating: {
                type: Number,
                min: 1,
                max: 5
            },
            review: {
                type: String,
                maxLength: [500, 'Review cannot exceed 500 characters']
            },
            ratedAt: Date
        }
    },

    // Expiry
    expiresAt: {
        type: Date,
        default: () => new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days
    },

    chatMetadata: {
        firstMessageAt: Date,
        lastMessageAt: Date,
        messageCount: {
            type: Number,
            default: 0
        },
        lastActivityBy: {
            type: String,
            enum: ['initiator', 'recipient']
        }
    },

    // Negotiation Progress Tracking with completion fields
    negotiationMetadata: {
        roundCount: {
            type: Number,
            default: 0
        },
        lastNegotiationUpdate: Date,
        negotiationStartedAt: Date,
        acceptedAt: Date,
        // Fields to track negotiation completion
        negotiationCompleted: {
            type: Boolean,
            default: false
        },
        negotiationCompletedAt: Date
    },

    // Activity Timestamps
    activityTimestamps: {
        initiatorLastSeen: Date,
        recipientLastSeen: Date,
        statusChangedAt: Date,
        lastOfferUpdateAt: Date
    },

    // Dispute Status
    disputeStatus: {
        hasDispute: { 
          type: Boolean, 
          default: false 
        }
      }
}, {
    timestamps: true
});

// Method to handle user acceptance
exchangeSchema.methods.acceptByUser = function(userSupabaseId) {
    const isInitiator = this.initiator.supabaseId === userSupabaseId;
    const now = new Date();
    
    if (isInitiator) {
        this.acceptance.initiatorAccepted = true;
        this.acceptance.initiatorAcceptedAt = now;
    } else {
        this.acceptance.recipientAccepted = true;
        this.acceptance.recipientAcceptedAt = now;
    }
    
    // Check if both have accepted
    if (this.acceptance.initiatorAccepted && this.acceptance.recipientAccepted) {
        this.status = 'accepted';
        this.acceptance.fullyAcceptedAt = now;
        this.negotiationMetadata.acceptedAt = now;
    } else {
        this.status = 'pending_acceptance';
    }
    
    this.activityTimestamps.statusChangedAt = now;
    return this;
};

// Method to check if user has accepted
exchangeSchema.methods.hasUserAccepted = function(userSupabaseId) {
    const isInitiator = this.initiator.supabaseId === userSupabaseId;
    return isInitiator ? this.acceptance?.initiatorAccepted : this.acceptance?.recipientAccepted;
};

// Method to get acceptance status
exchangeSchema.methods.getAcceptanceStatus = function() {
    return {
        initiatorAccepted: this.acceptance?.initiatorAccepted || false,
        recipientAccepted: this.acceptance?.recipientAccepted || false,
        bothAccepted: (this.acceptance?.initiatorAccepted && this.acceptance?.recipientAccepted) || false,
        pendingUser: !this.acceptance?.initiatorAccepted ? 'initiator' : 
                     !this.acceptance?.recipientAccepted ? 'recipient' : null
    };
};

// Chat availability includes pending_acceptance
exchangeSchema.methods.isChatAvailable = function () {
    return ['negotiating', 'pending_acceptance', 'accepted', 'in_progress'].includes(this.status);
};

exchangeSchema.methods.getChatParticipants = function () {
    return [
        { supabaseId: this.initiator.supabaseId, role: 'initiator' },
        { supabaseId: this.recipient.supabaseId, role: 'recipient' }
    ];
};

exchangeSchema.methods.updateLastActivity = function (userSupabaseId) {
    const isInitiator = this.initiator.supabaseId === userSupabaseId;
    if (isInitiator) {
        this.activityTimestamps.initiatorLastSeen = new Date();
    } else {
        this.activityTimestamps.recipientLastSeen = new Date();
    }
    return this.save();
};

exchangeSchema.methods.incrementMessageCount = function () {
    this.chatMetadata.messageCount += 1;
    this.chatMetadata.lastMessageAt = new Date();
    return this.save();
};

export default mongoose.models.Exchange || mongoose.model('Exchange', exchangeSchema);





















File: /models/Message.js

// models/Message.js

import mongoose from 'mongoose';

const messageSchema = new mongoose.Schema({
    // Exchange Integration (Primary Key Relationship)
    exchangeId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Exchange',
        required: true,
        index: true
    },

    // Message Content
    content: {
        type: String,
        required: function () {
            return this.type === 'user'; // Required only for user messages
        },
        maxLength: 1000,
        trim: true
    },

    // Sender Information
    sender: {
        userId: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'User',
            required: function () {
                return this.type === 'user'; // Required only for user messages
            }
        },
        supabaseId: {
            type: String,
            required: function () {
                return this.type === 'user'; // Required only for user messages
            }
        },
        role: {
            type: String,
            enum: ['initiator', 'recipient'],
            required: function () {
                return this.type === 'user'; // Required only for user messages
            }
        }
    },

    // Message Type
    type: {
        type: String,
        enum: [
            'user',              // Regular user messages
            'system',            // System notifications
            'offer_update',      // Offer change notifications
            'status_change'      // Exchange status updates
        ],
        required: true,
        default: 'user'
    },

    // System Message Data (for automated messages)
    systemData: {
        event: {
            type: String,
            enum: [
                'exchange_created',
                'negotiation_started',
                'offer_updated',
                'status_changed',
                'deadline_warning',
                'exchange_completed',
                'exchange_cancelled',
                'exchange_expired'
            ]
        },
        details: {
            previousOffer: mongoose.Schema.Types.Mixed,
            newOffer: mongoose.Schema.Types.Mixed,
            previousStatus: String,
            newStatus: String,
            triggeredBy: String, // supabaseId of user who triggered event
            metadata: mongoose.Schema.Types.Mixed
        }
    },

    // Read Status Tracking
    readBy: [{
        supabaseId: String,
        role: {
            type: String,
            enum: ['initiator', 'recipient']
        },
        readAt: {
            type: Date,
            default: Date.now
        }
    }],

    // Timestamps
    createdAt: {
        type: Date,
        default: Date.now
    }
}, {
    timestamps: true
});

// Indexes for Performance
messageSchema.index({ exchangeId: 1, createdAt: -1 }); // Main query pattern
messageSchema.index({ exchangeId: 1, type: 1 }); // Filter by message type
messageSchema.index({ 'sender.supabaseId': 1 }); // User message queries
messageSchema.index({ 'systemData.event': 1 }); // System message queries

// Virtual Fields
messageSchema.virtual('isUserMessage').get(function () {
    return this.type === 'user';
});

messageSchema.virtual('isSystemMessage').get(function () {
    return this.type !== 'user';
});

messageSchema.virtual('unreadCount').get(function () {
    return 2 - this.readBy.length; // 2 participants - read count
});

// Methods
messageSchema.methods.markAsRead = function (supabaseId, role) {
    const existingRead = this.readBy.find(read => read.supabaseId === supabaseId);
    if (!existingRead) {
        this.readBy.push({ supabaseId, role });
    }
    return this.save();
};

messageSchema.methods.isReadBy = function (supabaseId) {
    return this.readBy.some(read => read.supabaseId === supabaseId);
};

// Static Methods
messageSchema.statics.createSystemMessage = function (exchangeId, event, details = {}) {
    return this.create({
        exchangeId,
        type: 'system',
        systemData: { event, details }
    });
};

messageSchema.statics.getExchangeMessages = function (exchangeId, limit = 50, skip = 0) {
    return this.find({ exchangeId })
        .sort({ createdAt: -1 })
        .limit(limit)
        .skip(skip)
        .populate('sender.userId', 'name email');
};

messageSchema.statics.getUnreadCount = function (exchangeId, supabaseId) {
    return this.countDocuments({
        exchangeId,
        'readBy.supabaseId': { $ne: supabaseId }
    });
};

export default mongoose.models.Message || mongoose.model('Message', messageSchema);





















File: /models/NegotiationSession.js

// models/NegotiationSession.js
import mongoose from 'mongoose';

const negotiationSessionSchema = new mongoose.Schema({
    // Core reference
    exchangeId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Exchange',
        required: true,
        unique: true
    },

    // PRE-ACCEPTANCE TERMS (Essential deal terms)
    terms: {
        // Enhanced descriptions
        descriptions: {
            initiator: { type: String, maxLength: 500 },
            recipient: { type: String, maxLength: 500 }
        },
        // NEW: Selected skill ID per role
        skillIds: {
            initiator: { type: mongoose.Schema.Types.ObjectId, ref: 'Skill', default: null },
            recipient: { type: mongoose.Schema.Types.ObjectId, ref: 'Skill', default: null }
        },

        // Deliverables with completion tracking
        deliverables: {
            initiator: [{
                title: { type: String, required: true },
                completed: { type: Boolean, default: false },
                completedAt: Date,
                // NEW: Peer confirmation fields
                confirmedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
                confirmedAt: Date,
                // NEW: Dispute tracking
                disputeRaised: { type: Boolean, default: false },
                disputeReason: String
            }],
            recipient: [{
                title: { type: String, required: true },
                completed: { type: Boolean, default: false },
                completedAt: Date,
                // NEW: Same fields for recipient
                confirmedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
                confirmedAt: Date,
                disputeRaised: { type: Boolean, default: false },
                disputeReason: String
            }]
        },

        // Timeline and effort
        deadline: Date,
        hours: {
            initiator: { type: Number, min: 0, max: 100 },
            recipient: { type: Number, min: 0, max: 100 }
        },

        // Financial
        amount: { type: Number, min: 0, default: 0 },
        currency: { type: String, default: 'INR' },
        paymentTimeline: {
            type: String,
            enum: ['upfront', 'completion'],
            default: 'completion'
        },

        // Delivery method
        method: {
            type: String,
            enum: ['in-person', 'online', 'flexible'],
            default: 'flexible'
        }
    },

    // Agreement tracking
    agreed: {
        initiator: { type: Boolean, default: false },
        recipient: { type: Boolean, default: false },
        initiatorAt: Date,
        recipientAt: Date
    },

    // POST-ACCEPTANCE EXECUTION
    execution: {
        startDate: Date,
        contactShared: { type: Boolean, default: false }
    },

    // Simple status
    status: {
        type: String,
        enum: ['drafting', 'negotiating', 'agreed', 'completed'],
        default: 'drafting'
    },

    // Minimal tracking
    lastModifiedBy: String

}, {
    timestamps: true
});

// VIRTUAL FIELDS (Inferred from stored data)

// Total hours
negotiationSessionSchema.virtual('totalHours').get(function () {
    return (this.terms.hours.initiator || 0) + (this.terms.hours.recipient || 0);
});

// Add these methods to your existing negotiationSessionSchema

// Confirm deliverable (peer confirmation)
negotiationSessionSchema.methods.confirmDeliverable = async function (userRole, deliverableIndex, confirmingUserId) {
    const otherRole = userRole === 'initiator' ? 'recipient' : 'initiator';
    const deliverable = this.terms.deliverables[otherRole][deliverableIndex];
    
    if (deliverable && deliverable.completed && !deliverable.confirmedBy) {
        deliverable.confirmedBy = confirmingUserId;
        deliverable.confirmedAt = new Date();
        this.markModified('terms.deliverables');
        
        // Check if all deliverables are both completed and confirmed
        const allDeliverables = [
            ...this.terms.deliverables.initiator,
            ...this.terms.deliverables.recipient
        ];
        
        const allConfirmed = allDeliverables.every(d => d.completed && d.confirmedBy);
        
        if (allConfirmed) {
            this.status = 'completed';

            // NEW: Sync the linked Exchange document's status to 'completed'
            try {
                // Dynamic import to avoid circular dependency issues
                const { default: Exchange } = await import('./Exchange.js');

                await Exchange.findByIdAndUpdate(this.exchangeId, {
                    status: 'completed',
                    'activityTimestamps.statusChangedAt': new Date()
                });
            } catch (error) {
                console.error('Error syncing Exchange status to completed:', error);
                // We don't throw here to avoid blocking the negotiation save flow
            }
        }
    }
    
    return this.save();
};

// Raise dispute on deliverable
negotiationSessionSchema.methods.raiseDispute = function (userRole, deliverableIndex, reason) {
    const otherRole = userRole === 'initiator' ? 'recipient' : 'initiator';
    const deliverable = this.terms.deliverables[otherRole][deliverableIndex];
    
    if (deliverable && deliverable.completed) {
        deliverable.disputeRaised = true;
        deliverable.disputeReason = reason;
    }
    
    return this.save();
};


// Both parties agreed
negotiationSessionSchema.virtual('bothAgreed').get(function () {
    return this.agreed.initiator && this.agreed.recipient;
});

// Payment method (inferred from amount and exchange type)
negotiationSessionSchema.virtual('paymentMethod').get(function () {
    if (this.terms.amount === 0) return 'none';
    return this.terms.paymentTimeline || 'completion';
});

// Progress report (inferred from deliverable completion)
negotiationSessionSchema.virtual('progressReport').get(function () {
    const iDeliverables = this.terms.deliverables.initiator || [];
    const rDeliverables = this.terms.deliverables.recipient || [];

    const iCompleted = iDeliverables.filter(d => d.completed).length;
    const rCompleted = rDeliverables.filter(d => d.completed).length;
    const iConfirmed = iDeliverables.filter(d => d.completed && d.confirmedBy).length;
    const rConfirmed = rDeliverables.filter(d => d.completed && d.confirmedBy).length;
    
    const totalDeliverables = iDeliverables.length + rDeliverables.length;
    const totalCompleted = iCompleted + rCompleted;
    const totalConfirmed = iConfirmed + rConfirmed;

    return {
        initiator: {
            total: iDeliverables.length,
            completed: iCompleted,
            confirmed: iConfirmed,
            percentage: iDeliverables.length > 0 ? Math.round((iCompleted / iDeliverables.length) * 100) : 0,
            confirmedPercentage: iDeliverables.length > 0 ? Math.round((iConfirmed / iDeliverables.length) * 100) : 0
        },
        recipient: {
            total: rDeliverables.length,
            completed: rCompleted,
            confirmed: rConfirmed,
            percentage: rDeliverables.length > 0 ? Math.round((rCompleted / rDeliverables.length) * 100) : 0,
            confirmedPercentage: rDeliverables.length > 0 ? Math.round((rConfirmed / rDeliverables.length) * 100) : 0
        },
        overall: {
            total: totalDeliverables,
            completed: totalCompleted,
            confirmed: totalConfirmed,
            percentage: totalDeliverables > 0 ? Math.round((totalCompleted / totalDeliverables) * 100) : 0,
            confirmedPercentage: totalDeliverables > 0 ? Math.round((totalConfirmed / totalDeliverables) * 100) : 0
        }
    };
});


// SIMPLE METHODS

// FIXED: Mark agreement with Exchange status sync
negotiationSessionSchema.methods.markAgreement = async function (userSupabaseId, exchangeData) {
    const userRole = exchangeData.initiator.supabaseId === userSupabaseId ? 'initiator' : 'recipient';

    this.agreed[userRole] = true;
    this.agreed[`${userRole}At`] = new Date();
    this.lastModifiedBy = userSupabaseId;

    if (this.bothAgreed) {
        this.status = 'agreed';

        // FIXED: Update the linked Exchange status when both agree
        try {
            // Dynamic import to avoid circular dependency
            const { default: Exchange } = await import('./Exchange.js');

            await Exchange.findByIdAndUpdate(this.exchangeId, {
                status: 'pending_acceptance',
                // Add flag to track negotiation completion
                'negotiationMetadata.negotiationCompleted': true,
                'negotiationMetadata.negotiationCompletedAt': new Date()
            });
        } catch (error) {
            console.error('Error updating Exchange status:', error);
            // Don't throw here to avoid breaking the negotiation save
        }
    }

    return this.save();
};

// Update terms
negotiationSessionSchema.methods.updateTerms = function (newTerms, userSupabaseId) {
    Object.assign(this.terms, newTerms);

    // Reset agreements
    this.agreed.initiator = false;
    this.agreed.recipient = false;
    this.agreed.initiatorAt = null;
    this.agreed.recipientAt = null;

    this.status = 'negotiating';
    this.lastModifiedBy = userSupabaseId;

    return this.save();
};

// Mark deliverable complete
negotiationSessionSchema.methods.completeDeliverable = function (userRole, deliverableIndex, userId) {
    const deliverable = this.terms.deliverables[userRole][deliverableIndex];
    if (deliverable) {
        deliverable.completed = true;
        deliverable.completedAt = new Date();
        if (userId) {
            deliverable.completedBy = userId;
        }
        this.markModified('terms.deliverables');

        // Auto-complete if all deliverables done
        if (this.progressReport.overall.percentage === 100) {
            this.status = 'completed';
        }
    }

    return this.save();
};

// Start execution
negotiationSessionSchema.methods.startExecution = function (startDate) {
    this.execution.startDate = startDate;
    this.execution.contactShared = true;
    // Execution phase is now handled within the 'agreed' status. We keep the timestamp for reference but avoid a separate status.
    // this.status = 'executing';
    // Optionally keep status unchanged or ensure it's at least 'agreed'
    if (this.status !== 'agreed' && this.status !== 'completed') {
        this.status = 'agreed';
    }

    return this.save();
};

// SIMPLE INDEXES
negotiationSessionSchema.index({ status: 1 });

// AUTO-EXPIRE: mark exchange as expired when negotiation deadline has passed
negotiationSessionSchema.post('findOne', async function (doc) {
    if (!doc) return;

    const deadline = doc.terms?.deadline;
    if (deadline && deadline < new Date()) {
        try {
            const { default: Exchange } = await import('./Exchange.js');
            await Exchange.findByIdAndUpdate(doc.exchangeId, {
                status: 'expired',
                'activityTimestamps.statusChangedAt': new Date()
            });
        } catch (err) {
            console.error('Error auto-expiring exchange:', err);
        }
    }
});

export default mongoose.models.NegotiationSession || mongoose.model('NegotiationSession', negotiationSessionSchema);





















File: /models/Review.js

// models/Review.js
import mongoose from 'mongoose';

const ReviewSchema = new mongoose.Schema({
    exchangeId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Exchange',
        required: true
    },
    reviewerId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },
    revieweeId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },
    rating: {
        type: Number,
        required: true,
        min: 1,
        max: 5
    },
    comment: {
        type: String,
        maxlength: [500, 'Comment cannot be more than 500 characters'],
        trim: true
    }
}, {
    timestamps: true
});

// Ensure one review per user per exchange
ReviewSchema.index({ exchangeId: 1, reviewerId: 1 }, { unique: true });

export default mongoose.models.Review || mongoose.model('Review', ReviewSchema);





















File: /models/Skill.js

import mongoose from 'mongoose';

const skillSchema = new mongoose.Schema({
    title: {
        type: String,
        required: [true, 'Skill title is required'],
        trim: true,
        maxLength: [100, 'Title cannot exceed 100 characters']
    },
    description: {
        type: String,
        required: [true, 'Skill description is required'],
        trim: true,
        maxLength: [1000, 'Description cannot exceed 1000 characters']
    },
    category: {
        type: String,
        required: [true, 'Category is required'],
        enum: ['Technology', 'Design', 'Business', 'Language', 'Photography', 'Music', 'Handcraft', 'Education', 'Other']
    },
    level: {
        type: String,
        required: [true, 'Skill level is required'],
        enum: ['Beginner', 'Intermediate', 'Advanced', 'Expert']
    },
    tags: [{
        type: String,
        trim: true,
        maxLength: [30, 'Tag cannot exceed 30 characters']
    }],
    images: [{
        url: String,
        publicId: String, // For Cloudinary
        alt: String
    }],
    owner: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },
    ownerSupabaseId: {
        type: String,
        required: true
    },
    isAvailable: {
        type: Boolean,
        default: true
    },
    exchangeCount: {
        type: Number,
        default: 0
    },
    viewCount: {
        type: Number,
        default: 0
    },
    interestedUsers: [{
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    }],
    location: {
        type: String,
        trim: true
    },
    deliveryMethod: {
        type: String,
        enum: ['In-person', 'Online', 'Both'],
        default: 'Both'
    },
    estimatedDuration: {
        type: String,
        trim: true
    }
}, {
    timestamps: true
});

export default mongoose.models.Skill || mongoose.model('Skill', skillSchema);





















File: /models/SkillCategory.js

// models/SkillCategory.js
import mongoose from 'mongoose';

const skillCategorySchema = new mongoose.Schema({
    // Category name (matches your Skill schema)
    name: {
        type: String,
        required: true,
        unique: true,
        enum: ['Technology', 'Design', 'Business', 'Language', 'Photography', 'Music', 'Handcraft', 'Education', 'Other']
    },

    // Simple counters
    userCount: {
        type: Number,
        default: 0
    },

    skillCount: {
        type: Number,
        default: 0
    },

    totalViews: {
        type: Number,
        default: 0
    },

    totalExchanges: {
        type: Number,
        default: 0
    },

    // Most common level in this category
    popularLevel: {
        type: String,
        enum: ['Beginner', 'Intermediate', 'Advanced', 'Expert'],
        default: 'Beginner'
    },

    // Most common delivery method
    popularDeliveryMethod: {
        type: String,
        enum: ['In-person', 'Online', 'Both'],
        default: 'Both'
    }
}, {
    timestamps: true
});

// Simple method to update all stats
skillCategorySchema.methods.updateStats = async function () {
    const Skill = mongoose.model('Skill');
    const skills = await Skill.find({ category: this.name });

    this.skillCount = skills.length;
    this.totalViews = skills.reduce((sum, skill) => sum + skill.viewCount, 0);
    this.totalExchanges = skills.reduce((sum, skill) => sum + skill.exchangeCount, 0);

    // Count unique users
    const uniqueUsers = new Set(skills.map(skill => skill.owner.toString()));
    this.userCount = uniqueUsers.size;

    // Find most common level
    const levelCounts = {};
    skills.forEach(skill => {
        levelCounts[skill.level] = (levelCounts[skill.level] || 0) + 1;
    });
    this.popularLevel = Object.keys(levelCounts).reduce((a, b) =>
        levelCounts[a] > levelCounts[b] ? a : b, 'Beginner');

    // Find most common delivery method
    const deliveryCounts = {};
    skills.forEach(skill => {
        deliveryCounts[skill.deliveryMethod] = (deliveryCounts[skill.deliveryMethod] || 0) + 1;
    });
    this.popularDeliveryMethod = Object.keys(deliveryCounts).reduce((a, b) =>
        deliveryCounts[a] > deliveryCounts[b] ? a : b, 'Both');

    await this.save();
};

export default mongoose.models.SkillCategory || mongoose.model('SkillCategory', skillCategorySchema);





















File: /models/SkillView.js

import mongoose from 'mongoose';

const skillViewSchema = new mongoose.Schema({
    // Which skill was viewed
    skillId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Skill',
        required: true
    },

    // Who viewed it (if logged in)
    viewerId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    },
    viewerSupabaseId: {
        type: String
    },

    // Anonymous tracking data
    ipAddress: {
        type: String,
        required: true
    },
    userAgent: String,

    // When the view happened
    viewDate: {
        type: Date,
        default: Date.now,
        required: true
    }
}, {
    timestamps: true
});

// Indexes for efficient querying - crucial for chart performance
skillViewSchema.index({ skillId: 1, viewDate: -1 });
skillViewSchema.index({ viewDate: -1 });
skillViewSchema.index({ viewerSupabaseId: 1, viewDate: -1 });

// Method to get daily view counts for a specific skill
skillViewSchema.statics.getDailyViewsForSkill = function (skillId, days = 30) {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    return this.aggregate([
        {
            $match: {
                skillId: skillId,
                viewDate: { $gte: startDate }
            }
        },
        {
            $group: {
                _id: {
                    year: { $year: '$viewDate' },
                    month: { $month: '$viewDate' },
                    day: { $dayOfMonth: '$viewDate' }
                },
                count: { $sum: 1 }
            }
        },
        {
            $sort: { '_id.year': 1, '_id.month': 1, '_id.day': 1 }
        }
    ]);
};

// Method to get daily views for all skills owned by a user
skillViewSchema.statics.getDailyViewsForUser = function (userSupabaseId, days = 30) {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    return this.aggregate([
        {
            $lookup: {
                from: 'skills',
                localField: 'skillId',
                foreignField: '_id',
                as: 'skill'
            }
        },
        {
            $unwind: '$skill'
        },
        {
            $match: {
                'skill.ownerSupabaseId': userSupabaseId,
                viewDate: { $gte: startDate }
            }
        },
        {
            $group: {
                _id: {
                    year: { $year: '$viewDate' },
                    month: { $month: '$viewDate' },
                    day: { $dayOfMonth: '$viewDate' }
                },
                count: { $sum: 1 }
            }
        },
        {
            $sort: { '_id.year': 1, '_id.month': 1, '_id.day': 1 }
        }
    ]);
};

export default mongoose.models.SkillView || mongoose.model('SkillView', skillViewSchema);





















File: /models/User.js

import mongoose from 'mongoose';

const UserSchema = new mongoose.Schema({
    supabaseId: {
        type: String,
        required: true,
        unique: true,
    },
    email: {
        type: String,
        required: true,
        unique: true,
        lowercase: true,
    },
    name: {
        type: String,
        required: true,
        maxlength: [60, 'Name cannot be more than 60 characters'],
        trim: true,
    },
    avatar: String,
    bio: {
        type: String,
        maxlength: [500, 'Bio cannot be more than 500 characters'],
        trim: true,
    },
    skills: [{
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Skill'
    }],
    exchanges: [{
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Exchange'
    }],
    rating: {
        type: Number,
        default: 0,
        min: 0,
        max: 5,
    },
    reviewCount: {
        type: Number,
        default: 0,
        min: 0,
    },
    isActive: {
        type: Boolean,
        default: true,
    },
    location: {
        type: String,
        trim: true,
        maxlength: [100, 'Location cannot be more than 100 characters'],
    },
    preferences: {
        notifications: {
            email: { type: Boolean, default: true },
            push: { type: Boolean, default: true },
            exchanges: { type: Boolean, default: true },
            messages: { type: Boolean, default: true },
        },
        privacy: {
            showEmail: { type: Boolean, default: false },
            showLocation: { type: Boolean, default: true },
            profileVisibility: {
                type: String,
                enum: ['public', 'private'],
                default: 'public'
            },
        }
    },
    stats: {
        totalSkills: { type: Number, default: 0 },
        activeSkills: { type: Number, default: 0 },
        totalViews: { type: Number, default: 0 },
        successfulExchanges: { type: Number, default: 0 },
    },
    lastActive: {
        type: Date,
        default: Date.now,
    },
    profileEditedFields: {
        name: { type: Boolean, default: false },
        avatar: { type: Boolean, default: false },
        bio: { type: Boolean, default: false },
        location: { type: Boolean, default: false }
    },
    adminMetadata: {
        isAdmin: { type: Boolean, default: false },
        disputesHandled: { type: Number, default: 0 },
        lastAdminActivity: Date
      }
}, {
    timestamps: true, // Keeps createdAt and updatedAt
});

export default mongoose.models.User || mongoose.model('User', UserSchema);





















File: /Providers/ThemeProvider.js

'use client';
import { createContext, useContext, useEffect, useState } from 'react';
import Cookies from 'js-cookie';

const ThemeContext = createContext();

export function ThemeProvider({ children, initialTheme }) {
    const [theme, setTheme] = useState(initialTheme || 'light');
    const [mounted, setMounted] = useState(false);

    useEffect(() => {
        setMounted(true);
        const savedTheme = Cookies.get('theme') || 'light';
        setTheme(savedTheme);

        if (savedTheme === 'dark') {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    }, []);

    const toggleTheme = () => {
        const newTheme = theme === 'light' ? 'dark' : 'light';
        setTheme(newTheme);
        Cookies.set('theme', newTheme, { expires: 365 });
        if (newTheme === 'dark') {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    };

    return (
        <ThemeContext.Provider value={{ theme, toggleTheme }}>
            <div style={!mounted ? { visibility: 'hidden' } : undefined}>
                {children}
            </div>
        </ThemeContext.Provider>
    );
}

export function useTheme() {
    const context = useContext(ThemeContext);
    if (!context) {
        throw new Error('useTheme must be used within a ThemeProvider');
    }
    return context;
}





















File: /server.js

// server.js

import { createServer } from 'http';
import { Server } from 'socket.io';
import next from 'next';
import connectDB from './lib/mongodb.js';
import Message from './models/Message.js';
import Exchange from './models/Exchange.js';
import User from './models/User.js';

const dev = process.env.NODE_ENV !== 'production';
const hostname = 'localhost';
const port = 3000;

// Prepare the Next.js app
const app = next({ dev, hostname, port });
const handler = app.getRequestHandler();

app.prepare().then(() => {
    // Create HTTP server
    const httpServer = createServer(handler);

    // Create Socket.IO server
    const io = new Server(httpServer, {
        cors: {
            origin: process.env.NODE_ENV === 'production'
                ? process.env.NEXT_PUBLIC_SITE_URL
                : "http://localhost:3000",
            methods: ["GET", "POST"]
        }
    });

    // Socket.IO connection handling
    io.on('connection', (socket) => {
        console.log('User connected:', socket.id);

        // Join exchange room (single room for chat + negotiation)
        socket.on('join-exchange-chat', async (data) => {
            const { exchangeId, userSupabaseId } = data;

            try {
                await connectDB();

                // Find exchange and validate participant
                const exchange = await Exchange.findById(exchangeId);
                if (!exchange) {
                    socket.emit('chat-error', { message: 'Exchange not found' });
                    return;
                }

                const isParticipant =
                    exchange.initiator.supabaseId === userSupabaseId ||
                    exchange.recipient.supabaseId === userSupabaseId;

                if (!isParticipant) {
                    socket.emit('chat-error', { message: 'Not authorized for this exchange' });
                    return;
                }

                // UPDATED: Check if chat is available for current status (includes pending_acceptance)
                const chatAvailableStatuses = ['negotiating', 'pending_acceptance', 'accepted', 'in_progress'];
                if (!chatAvailableStatuses.includes(exchange.status)) {
                    socket.emit('chat-error', {
                        message: `Chat not available. Exchange status: ${exchange.status}`
                    });
                    return;
                }

                // Leave any previous rooms
                socket.rooms.forEach(room => {
                    if (room !== socket.id) {
                        socket.leave(room);
                    }
                });

                // Join single room for both chat and negotiation
                const roomName = `exchange-${exchangeId}`;
                socket.join(roomName);

                // Store user data on socket
                socket.userSupabaseId = userSupabaseId;
                socket.currentExchangeId = exchangeId;
                socket.currentRoom = roomName;
                socket.userRole = exchange.initiator.supabaseId === userSupabaseId ? 'initiator' : 'recipient';

                console.log(`User ${userSupabaseId} (${socket.userRole}) joined exchange ${exchangeId}`);

            } catch (error) {
                console.error('Error joining exchange chat:', error);
                socket.emit('chat-error', { message: 'Failed to join exchange chat' });
            }
        });

        // Send chat message (simple timestamp-based ordering)
        socket.on('send-exchange-message', async (messageData) => {
            const { exchangeId, content, messageId } = messageData;

            if (!exchangeId || !content || !socket.userSupabaseId) {
                socket.emit('chat-error', { message: 'Invalid message data' });
                return;
            }

            try {
                await connectDB();

                // UPDATED: Verify exchange is still available for chat (includes pending_acceptance)
                const exchange = await Exchange.findById(exchangeId);
                if (!exchange || !['negotiating', 'pending_acceptance', 'accepted', 'in_progress'].includes(exchange.status)) {
                    socket.emit('chat-error', { message: 'Chat no longer available for this exchange' });
                    return;
                }

                // Find user
                const user = await User.findOne({ supabaseId: socket.userSupabaseId }).select('_id');
                if (!user) {
                    socket.emit('chat-error', { message: 'User not found' });
                    return;
                }

                // Create and save message (no sequence - just timestamp ordering)
                const newMessage = new Message({
                    exchangeId,
                    content: content.trim(),
                    sender: {
                        userId: user._id,
                        supabaseId: socket.userSupabaseId,
                        role: socket.userRole
                    },
                    type: 'user'
                });

                const savedMessage = await newMessage.save();

                // Broadcast message to all users in room
                const messagePayload = {
                    _id: savedMessage._id,
                    messageId: savedMessage._id,
                    content: savedMessage.content,
                    sender: savedMessage.sender,
                    timestamp: savedMessage.createdAt,
                    createdAt: savedMessage.createdAt,
                    type: savedMessage.type,
                    readBy: savedMessage.readBy || []
                };

                io.to(socket.currentRoom).emit('new-exchange-message', messagePayload);

                // Send delivery confirmation to sender
                if (messageId) {
                    socket.emit('message-delivered', {
                        messageId: savedMessage._id,
                        tempId: messageId,
                        timestamp: savedMessage.createdAt
                    });
                }

                console.log(`Message sent in exchange ${exchangeId}`);

            } catch (error) {
                console.error('Error sending exchange message:', error);
                socket.emit('chat-error', { message: 'Failed to send message' });
            }
        });

        // Handle real-time offer updates
        socket.on('offer-updated', (data) => {
            const { exchangeId, offerType, newOffer } = data;

            if (socket.currentRoom) {
                // Broadcast offer update to negotiation playground
                socket.to(socket.currentRoom).emit('offer-updated-realtime', {
                    exchangeId,
                    offerType,
                    newOffer,
                    userSupabaseId: socket.userSupabaseId,
                    timestamp: new Date().toISOString()
                });

                console.log(`Offer updated in exchange ${exchangeId} by ${socket.userSupabaseId}`);
            }
        });

        // NEW: Handle user acceptance events
        socket.on('user-accepted', (data) => {
            const { exchangeId, userSupabaseId, newStatus, acceptanceData, message } = data;

            if (socket.currentRoom) {
                // Broadcast acceptance to other participants
                socket.to(socket.currentRoom).emit('user-accepted-exchange', {
                    exchangeId,
                    userSupabaseId,
                    newStatus,
                    acceptanceData,
                    message,
                    timestamp: new Date().toISOString()
                });

                console.log(`User ${userSupabaseId} accepted exchange ${exchangeId}. New status: ${newStatus}`);
            }
        });

        // UPDATED: Handle exchange status changes (includes acceptance data)
        socket.on('status-changed', (data) => {
            const { exchangeId, newStatus, previousStatus, acceptanceData } = data;

            if (socket.currentRoom) {
                // Broadcast status change with acceptance data
                socket.to(socket.currentRoom).emit('status-changed-realtime', {
                    exchangeId,
                    newStatus,
                    previousStatus,
                    acceptanceData, // NEW: Include acceptance data
                    timestamp: new Date().toISOString()
                });

                // Close chat if exchange reaches terminal status
                const chatUnavailableStatuses = ['completed', 'cancelled', 'expired'];
                if (chatUnavailableStatuses.includes(newStatus)) {
                    io.to(socket.currentRoom).emit('chat-closed', {
                        reason: `Exchange ${newStatus}`,
                        timestamp: new Date().toISOString()
                    });
                }

                console.log(`Exchange ${exchangeId} status changed from ${previousStatus} to ${newStatus}`);
            }
        });

        // Handle typing indicators
        socket.on('typing-start', () => {
            if (socket.currentRoom) {
                socket.to(socket.currentRoom).emit('user-typing', {
                    userSupabaseId: socket.userSupabaseId,
                    userRole: socket.userRole,
                    isTyping: true
                });
            }
        });

        socket.on('typing-stop', () => {
            if (socket.currentRoom) {
                socket.to(socket.currentRoom).emit('user-typing', {
                    userSupabaseId: socket.userSupabaseId,
                    userRole: socket.userRole,
                    isTyping: false
                });
            }
        });

        // Leave exchange room
        socket.on('leave-exchange-chat', () => {
            if (socket.currentRoom && socket.userSupabaseId) {
                console.log(`User ${socket.userSupabaseId} leaving exchange ${socket.currentExchangeId}`);
                socket.leave(socket.currentRoom);
            }
        });

        // Handle disconnection
        socket.on('disconnect', (reason) => {
            console.log('User disconnected:', socket.id, 'Reason:', reason);
        });

        // Basic error handling
        socket.on('error', (error) => {
            console.error('Socket error for user:', socket.userSupabaseId, error);
            socket.emit('chat-error', { message: 'Connection error occurred' });
        });
    });

    // Start the server
    httpServer.listen(port, (err) => {
        if (err) throw err;
        console.log(`> Ready on http://${hostname}:${port}`);
        console.log('> Socket.IO server running with simplified exchange chat and two-step acceptance');
    });
});





















File: /utils/exchangeChatHelpers.js

// utils/exchangeChatHelpers.js

// Chat availability status constants (UPDATED)
export const CHAT_AVAILABLE_STATUSES = ['negotiating', 'pending_acceptance', 'accepted', 'in_progress'];
export const CHAT_UNAVAILABLE_STATUSES = ['pending', 'completed', 'cancelled', 'expired'];

// Exchange status messages (UPDATED with pending_acceptance)
export const EXCHANGE_STATUS_MESSAGES = {
    'pending': {
        message: 'Chat will be available once negotiation begins',
        color: 'text-yellow-600 dark:text-yellow-400',
        bgColor: 'bg-yellow-50 dark:bg-yellow-900/20',
        borderColor: 'border-yellow-200 dark:border-yellow-800'
    },
    'negotiating': {
        message: 'Chat is active - negotiate your exchange details',
        color: 'text-blue-600 dark:text-blue-400',
        bgColor: 'bg-blue-50 dark:bg-blue-900/20',
        borderColor: 'border-blue-200 dark:border-blue-800'
    },
    'pending_acceptance': {
        message: 'Chat is active - waiting for final acceptance from both parties',
        color: 'text-orange-600 dark:text-orange-400',
        bgColor: 'bg-orange-50 dark:bg-orange-900/20',
        borderColor: 'border-orange-200 dark:border-orange-800'
    },
    'accepted': {
        message: 'Chat is active - coordinate your exchange',
        color: 'text-green-600 dark:text-green-400',
        bgColor: 'bg-green-50 dark:bg-green-900/20',
        borderColor: 'border-green-200 dark:border-green-800'
    },
    'in_progress': {
        message: 'Chat is active - track progress and communicate',
        color: 'text-purple-600 dark:text-purple-400',
        bgColor: 'bg-purple-50 dark:bg-purple-900/20',
        borderColor: 'border-purple-200 dark:border-purple-800'
    },
    'completed': {
        message: 'Exchange completed - chat is now closed',
        color: 'text-gray-600 dark:text-gray-400',
        bgColor: 'bg-gray-50 dark:bg-gray-900/20',
        borderColor: 'border-gray-200 dark:border-gray-800'
    },
    'cancelled': {
        message: 'Exchange cancelled - chat is no longer available',
        color: 'text-red-600 dark:text-red-400',
        bgColor: 'bg-red-50 dark:bg-red-900/20',
        borderColor: 'border-red-200 dark:border-red-800'
    },
    'expired': {
        message: 'Exchange expired - chat is no longer available',
        color: 'text-orange-600 dark:text-orange-400',
        bgColor: 'bg-orange-50 dark:bg-orange-900/20',
        borderColor: 'border-orange-200 dark:border-orange-800'
    }
};

/**
 * Check if chat is available for given exchange status
 * @param {string} status - Exchange status
 * @returns {boolean} - Whether chat is available
 */
export const isChatAvailable = (status) => {
    return CHAT_AVAILABLE_STATUSES.includes(status);
};

/**
 * Get status message and styling for exchange status
 * @param {string} status - Exchange status
 * @returns {object} - Message object with styling
 */
export const getExchangeStatusInfo = (status) => {
    return EXCHANGE_STATUS_MESSAGES[status] || {
        message: 'Unknown exchange status',
        color: 'text-gray-600 dark:text-gray-400',
        bgColor: 'bg-gray-50 dark:bg-gray-900/20',
        borderColor: 'border-gray-200 dark:border-gray-800'
    };
};

/**
 * NEW: Check if user can accept the exchange
 * @param {object} exchange - Exchange object
 * @param {string} userSupabaseId - User's Supabase ID
 * @returns {object} - Acceptance status and capabilities
 */
export const getUserAcceptanceStatus = (exchange, userSupabaseId) => {
    if (!exchange || !userSupabaseId) {
        return {
            canAccept: false,
            hasAccepted: false,
            reason: 'Invalid exchange or user'
        };
    }

    const isInitiator = exchange.initiator?.supabaseId === userSupabaseId;
    const isRecipient = exchange.recipient?.supabaseId === userSupabaseId;
    
    if (!isInitiator && !isRecipient) {
        return {
            canAccept: false,
            hasAccepted: false,
            reason: 'Not a participant in this exchange'
        };
    }

    // Check if status allows acceptance
    if (!['negotiating', 'pending_acceptance'].includes(exchange.status)) {
        return {
            canAccept: false,
            hasAccepted: false,
            reason: `Cannot accept in current status: ${exchange.status}`
        };
    }

    const hasUserAccepted = isInitiator 
        ? exchange.acceptance?.initiatorAccepted 
        : exchange.acceptance?.recipientAccepted;

    const otherUserAccepted = isInitiator 
        ? exchange.acceptance?.recipientAccepted 
        : exchange.acceptance?.initiatorAccepted;

    const bothAccepted = exchange.acceptance?.initiatorAccepted && exchange.acceptance?.recipientAccepted;

    return {
        canAccept: !hasUserAccepted && ['negotiating', 'pending_acceptance'].includes(exchange.status),
        hasAccepted: hasUserAccepted || false,
        otherUserAccepted: otherUserAccepted || false,
        bothAccepted: bothAccepted || false,
        userRole: isInitiator ? 'initiator' : 'recipient',
        status: exchange.status
    };
};

/**
 * NEW: Get acceptance status message for UI display
 * @param {object} exchange - Exchange object
 * @param {string} userSupabaseId - User's Supabase ID
 * @returns {object} - Message and styling for acceptance status
 */
export const getAcceptanceStatusMessage = (exchange, userSupabaseId) => {
    const acceptanceStatus = getUserAcceptanceStatus(exchange, userSupabaseId);
    
    if (!acceptanceStatus.canAccept && !acceptanceStatus.hasAccepted) {
        return {
            message: acceptanceStatus.reason,
            color: 'text-gray-600 dark:text-gray-400',
            bgColor: 'bg-gray-50 dark:bg-gray-900/20'
        };
    }

    if (acceptanceStatus.bothAccepted) {
        return {
            message: 'Both parties have accepted this exchange',
            color: 'text-green-600 dark:text-green-400',
            bgColor: 'bg-green-50 dark:bg-green-900/20'
        };
    }

    if (acceptanceStatus.hasAccepted && !acceptanceStatus.otherUserAccepted) {
        return {
            message: 'You have accepted. Waiting for other party to accept.',
            color: 'text-orange-600 dark:text-orange-400',
            bgColor: 'bg-orange-50 dark:bg-orange-900/20'
        };
    }

    if (!acceptanceStatus.hasAccepted && acceptanceStatus.otherUserAccepted) {
        return {
            message: 'Other party has accepted. Your acceptance is needed.',
            color: 'text-blue-600 dark:text-blue-400',
            bgColor: 'bg-blue-50 dark:bg-blue-900/20'
        };
    }

    if (acceptanceStatus.canAccept) {
        return {
            message: 'Ready for acceptance by both parties',
            color: 'text-blue-600 dark:text-blue-400',
            bgColor: 'bg-blue-50 dark:bg-blue-900/20'
        };
    }

    return {
        message: 'Acceptance status unknown',
        color: 'text-gray-600 dark:text-gray-400',
        bgColor: 'bg-gray-50 dark:bg-gray-900/20'
    };
};

/**
 * Validate if user can access exchange chat
 * @param {object} exchange - Exchange object
 * @param {string} userSupabaseId - User's Supabase ID
 * @returns {object} - Validation result
 */
export const validateChatAccess = (exchange, userSupabaseId) => {
    if (!exchange) {
        return {
            canAccess: false,
            reason: 'Exchange not found'
        };
    }

    // Check if user is a participant
    const isInitiator = exchange.initiator?.supabaseId === userSupabaseId;
    const isRecipient = exchange.recipient?.supabaseId === userSupabaseId;
    const isParticipant = isInitiator || isRecipient;

    if (!isParticipant) {
        return {
            canAccess: false,
            reason: 'You are not a participant in this exchange'
        };
    }

    // Check if chat is available for current status
    const chatAvailable = isChatAvailable(exchange.status);

    if (!chatAvailable) {
        const statusInfo = getExchangeStatusInfo(exchange.status);
        return {
            canAccess: false,
            reason: statusInfo.message,
            status: exchange.status,
            userRole: isInitiator ? 'initiator' : 'recipient'
        };
    }

    return {
        canAccess: true,
        userRole: isInitiator ? 'initiator' : 'recipient',
        otherParticipant: isInitiator ? exchange.recipient : exchange.initiator,
        status: exchange.status
    };
};

/**
 * Format chat participant display name
 * @param {object} participant - Participant object
 * @param {string} role - User role (initiator/recipient)
 * @param {boolean} isCurrentUser - Whether this is current user
 * @returns {string} - Formatted display name
 */
export const formatParticipantName = (participant, role, isCurrentUser = false) => {
    if (isCurrentUser) return 'You';

    const name = participant?.userId?.name || participant?.name || 'Unknown User';
    const roleLabel = role === 'initiator' ? 'Initiator' : 'Recipient';

    return `${name} (${roleLabel})`;
};

/**
 * Calculate exchange timeline information
 * @param {object} exchange - Exchange object
 * @returns {object} - Timeline information
 */
export const getExchangeTimeline = (exchange) => {
    const now = new Date();
    const createdAt = new Date(exchange.createdAt);
    const expiresAt = exchange.expiresAt ? new Date(exchange.expiresAt) : null;

    // Time since creation
    const daysSinceCreation = Math.floor((now - createdAt) / (1000 * 60 * 60 * 24));

    // Time remaining
    let daysRemaining = null;
    let isExpiringSoon = false;

    if (expiresAt && expiresAt > now) {
        const timeRemaining = expiresAt.getTime() - now.getTime();
        daysRemaining = Math.ceil(timeRemaining / (1000 * 60 * 60 * 24));
        isExpiringSoon = daysRemaining <= 3; // Expiring in 3 days or less
    }

    return {
        daysSinceCreation,
        daysRemaining,
        isExpiringSoon,
        isExpired: expiresAt && expiresAt <= now,
        createdAt,
        expiresAt
    };
};

/**
 * Get chat room identifier for socket
 * @param {string} exchangeId - Exchange ID
 * @returns {string} - Socket room identifier
 */
export const getChatRoomId = (exchangeId) => {
    return `exchange-${exchangeId}`;
};

/**
 * Check if message is from current user
 * @param {object} message - Message object
 * @param {string} userSupabaseId - Current user's Supabase ID
 * @returns {boolean} - Whether message is from current user
 */
export const isMessageFromCurrentUser = (message, userSupabaseId) => {
    return message?.sender?.supabaseId === userSupabaseId;
};

/**
 * Get unread message count for user
 * @param {array} messages - Array of messages
 * @param {string} userSupabaseId - User's Supabase ID
 * @returns {number} - Count of unread messages
 */
export const getUnreadMessageCount = (messages, userSupabaseId) => {
    return messages.filter(message =>
        !message.readBy?.some(read => read.supabaseId === userSupabaseId)
    ).length;
};

/**
 * Format message timestamp for display
 * @param {string|Date} timestamp - Message timestamp
 * @param {boolean} showTime - Whether to show time
 * @returns {string} - Formatted timestamp
 */
export const formatMessageTimestamp = (timestamp, showTime = true) => {
    const date = new Date(timestamp);
    const now = new Date();
    const diffInHours = (now - date) / (1000 * 60 * 60);

    if (diffInHours < 1) {
        return 'Just now';
    } else if (diffInHours < 24) {
        return showTime ? date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'Today';
    } else if (diffInHours < 48) {
        return showTime ? `Yesterday ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}` : 'Yesterday';
    } else {
        return date.toLocaleDateString();
    }
};

/**
 * Validate message content before sending
 * @param {string} content - Message content
 * @returns {object} - Validation result
 */
export const validateMessageContent = (content) => {
    if (!content || !content.trim()) {
        return {
            isValid: false,
            error: 'Message cannot be empty'
        };
    }

    if (content.length > 1000) {
        return {
            isValid: false,
            error: 'Message cannot exceed 1000 characters'
        };
    }

    return {
        isValid: true,
        trimmedContent: content.trim()
    };
};

/**
 * Sort messages by timestamp (simple ordering)
 * @param {array} messages - Array of messages
 * @returns {array} - Sorted messages array
 */
export const sortMessagesByTimestamp = (messages) => {
    return [...messages].sort((a, b) => {
        const timeA = new Date(a.createdAt || a.timestamp).getTime();
        const timeB = new Date(b.createdAt || b.timestamp).getTime();
        return timeA - timeB;
    });
};

/**
 * Simple duplicate detection by message ID
 * @param {object} newMessage - New message to check
 * @param {array} existingMessages - Array of existing messages
 * @returns {boolean} - Whether message is a duplicate
 */
export const isDuplicateMessage = (newMessage, existingMessages = []) => {
    if (!newMessage._id) return false;
    
    return existingMessages.some(existing => existing._id === newMessage._id);
};

/**
 * Generate temporary message ID for optimistic updates
 * @returns {string} - Temporary message ID
 */
export const generateTempMessageId = () => {
    return `temp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
};





















File: /utils/NavbarWrapper.js

'use client';

import Navbar from '@/components/Navbar';
import { usePathname } from 'next/navigation';

export default function NavbarWrapper({ children }) {
    const pathname = usePathname();
    if(pathname === '/auth' || pathname.startsWith('/profile') || pathname.startsWith('/admin')) return children;
    if(pathname.includes('/negotiate')) return children;
    return (
        <>
            <Navbar />
            {children}
        </>
    );
}





















File: /utils/roleBasedPermissions.js

// utils/roleBasedPermissions.js

// UPDATED: Simplified role mapping for new 2-type system
const EXCHANGE_ROLE_MAPPING = {
    'skill_for_skill': {
        initiator: 'skill_provider',
        recipient: 'skill_provider'
    },
    'skill_for_money': {
        // For skill_for_money, roles are determined by actual offer types
        // This will be handled dynamically in getUserRoleInExchange
        initiator: 'dynamic',
        recipient: 'dynamic'
    }
};

// What each role can edit (unchanged)
const ROLE_PERMISSIONS = {
    skill_provider: {
        canEdit: ['description', 'deliverables', 'hours', 'deadline', 'method', 'skill_id']
    },
    money_provider: {
        canEdit: ['description', 'amount', 'currency', 'payment_timeline', 'deliverables']
    }
};

// UPDATED: Enhanced function to handle dynamic role determination
export function getUserRoleInExchange(exchange, userSupabaseId) {
    const isInitiator = exchange.initiator.supabaseId === userSupabaseId;
    const exchangeRole = isInitiator ? 'initiator' : 'recipient';
    
    let businessRole;
    
    if (exchange.exchangeType === 'skill_for_skill') {
        // Both provide skills
        businessRole = 'skill_provider';
    } else if (exchange.exchangeType === 'skill_for_money') {
        // UPDATED: Determine role by looking at actual offer types
        if (isInitiator) {
            // Check what the initiator is offering
            businessRole = exchange.initiatorOffer?.type === 'money' ? 'money_provider' : 'skill_provider';
        } else {
            // Check what the recipient is offering
            businessRole = exchange.recipientOffer?.type === 'money' ? 'money_provider' : 'skill_provider';
        }
    } else {
        // Fallback for any other exchange type
        businessRole = 'skill_provider';
    }

    return {
        exchangeRole,      // 'initiator' or 'recipient'
        businessRole,      // 'skill_provider' or 'money_provider'  
        isInitiator
    };
}

// Check if user can edit specific field (unchanged)
export function canEditField(businessRole, fieldName) {
    return ROLE_PERMISSIONS[businessRole]?.canEdit.includes(fieldName) || false;
}

// Export constants for use in other components
export { ROLE_PERMISSIONS, EXCHANGE_ROLE_MAPPING };





















File: /utils/ThemeProviderWrapper.js

'use client';
import { ThemeProvider } from '@/Providers/ThemeProvider';

export default function ThemeProviderWrapper({ children, initialTheme }) {
    return (
        <ThemeProvider initialTheme={initialTheme}>
            {children}
        </ThemeProvider>
    );
}





















File: /utils/updateSkillCategories.js

// utils/updateSkillCategories.js
import SkillCategory from '@/models/SkillCategory';

export async function updateSkillCategoryStats(categoryName) {
    try {
        let category = await SkillCategory.findOne({ name: categoryName });

        if (!category) {
            category = new SkillCategory({ name: categoryName });
        }

        await category.updateStats();
        return category;
    } catch (error) {
        console.error('Error updating skill category stats:', error);
        throw error;
    }
}

// Update all categories
export async function updateAllCategoryStats() {
    const categories = ['Technology', 'Design', 'Business', 'Language', 'Photography', 'Music', 'Handcraft', 'Education', 'Other'];

    for (const categoryName of categories) {
        await updateSkillCategoryStats(categoryName);
    }
}





















